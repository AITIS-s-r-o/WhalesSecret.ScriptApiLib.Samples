# NOTE: Requires **VS2019 16.3** or later

# Microsoft Managed Recommended Rules
# Description: These rules focus on the most critical problems in your code, including potential security holes, application crashes,
# and other important logic and design errors. It is recommended to include this rule set in any custom rule set you create for your projects.

# top-most EditorConfig file
root = true

[*.{cs,vb,csproj,md,ps1,xaml,props,snippet}]
end_of_line = crlf
indent_style = space
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = false

# Spell Checker rules.
# https://learn.microsoft.com/en-us/visualstudio/ide/text-spell-checker?view=vs-2022
spelling_languages = en-us
spelling_checkable_types = strings,identifiers,comments
spelling_error_severity = information
spelling_exclusion_path = .\exclusion.dic

# PowerShell files
[*.ps1]
indent_size = 4

# C# project files
[*.{csproj,props}]
indent_size = 2

# Code files
[*.{cs,vb,xaml}]
indent_size = 4

#### .NET Coding Conventions ####

# Organize usings
dotnet_separate_import_directive_groups = false
dotnet_sort_system_directives_first = true
file_header_template = unset

# this. and Me. preferences
dotnet_style_qualification_for_field = true:warning
dotnet_style_qualification_for_property = true:warning
dotnet_style_qualification_for_method = true:warning
dotnet_style_qualification_for_event = true:warning

# Language keywords vs BCL types preferences
dotnet_style_predefined_type_for_locals_parameters_members = true:warning
dotnet_style_predefined_type_for_member_access = true:warning

# Modifier preferences
dotnet_style_require_accessibility_modifiers = always:warning
csharp_preferred_modifier_order = public, private, protected, internal, file, static, extern, new, virtual, abstract, sealed, override, readonly, unsafe, required, volatile, async:warning
dotnet_style_readonly_field = true:warning

# Parentheses preferences
dotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:warning
dotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:warning
dotnet_style_parentheses_in_other_binary_operators = always_for_clarity:warning
dotnet_style_parentheses_in_other_operators = never_if_unnecessary:silent

# Expression-level preferences
dotnet_style_collection_initializer = true:suggestion
dotnet_style_explicit_tuple_names = true:warning
dotnet_style_prefer_inferred_tuple_names = true:suggestion
dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion
dotnet_style_prefer_auto_properties = true:warning
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion
dotnet_style_prefer_compound_assignment = true:suggestion

dotnet_style_prefer_simplified_boolean_expressions = true:suggestion
dotnet_style_prefer_simplified_interpolation = true:suggestion
dotnet_style_operator_placement_when_wrapping = beginning_of_line:warning

# Null-checking preferences
dotnet_style_coalesce_expression = false:silent
dotnet_style_null_propagation = false:silent
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion

# Parameter preferences
dotnet_code_quality_unused_parameters = all:suggestion


#### C# Coding Conventions ####

# Implicit and explicit types
csharp_style_var_for_built_in_types = false:warning
csharp_style_var_when_type_is_apparent = false:warning
csharp_style_var_elsewhere = false:warning
csharp_style_implicit_object_creation_when_type_is_apparent = true:warning

# Expression-bodied members
csharp_style_expression_bodied_methods = when_on_single_line:silent
csharp_style_expression_bodied_constructors = false:silent
csharp_style_expression_bodied_operators = when_on_single_line:suggestion
csharp_style_expression_bodied_properties = when_on_single_line:suggestion
csharp_style_expression_bodied_indexers = when_on_single_line:suggestion
csharp_style_expression_bodied_accessors = when_on_single_line:suggestion
csharp_style_expression_bodied_lambdas = when_on_single_line:silent
csharp_style_expression_bodied_local_functions = false:suggestion

# Pattern matching
csharp_style_pattern_matching_over_is_with_cast_check = true:suggestion
csharp_style_pattern_matching_over_as_with_null_check = true:suggestion

# Inlined variable declarations
csharp_style_inlined_variable_declaration = false:suggestion

# C# expression-level preferences
csharp_prefer_simple_default_expression = true:warning

# C# null-checking preferences
csharp_style_throw_expression = false:suggestion
csharp_style_conditional_delegate_call = false:suggestion

# Code-block preferences
csharp_prefer_braces = false:silent

# Unused value preferences
csharp_style_unused_value_expression_statement_preference = discard_variable:suggestion
csharp_style_unused_value_assignment_preference = discard_variable:warning

# Index and range preferences
csharp_style_prefer_index_operator = true:suggestion
csharp_style_prefer_range_operator = true:suggestion

# Miscellaneous preferences
csharp_style_deconstructed_variable_declaration = true:suggestion
csharp_style_pattern_local_over_anonymous_function = true:suggestion
csharp_using_directive_placement = outside_namespace:warning
csharp_prefer_static_local_function = true:suggestion
csharp_prefer_simple_using_statement = true:suggestion
csharp_style_prefer_switch_expression = false:suggestion
csharp_style_namespace_declarations = file_scoped:warning

#### C# Formatting Rules ####

# New-line options
csharp_new_line_before_open_brace = all
csharp_new_line_before_else = true
csharp_new_line_before_catch = true
csharp_new_line_before_finally = true
csharp_new_line_before_members_in_object_initializers = true
csharp_new_line_before_members_in_anonymous_types = true
csharp_new_line_between_query_expression_clauses = true

# Indentation preferences
csharp_indent_case_contents = true
csharp_indent_switch_labels = true
csharp_indent_labels = one_less_than_current
csharp_indent_block_contents = true
csharp_indent_braces = false
csharp_indent_case_contents_when_block = false

# Space preferences
csharp_space_after_cast = false
csharp_space_after_keywords_in_control_flow_statements = true
csharp_space_between_parentheses = none
csharp_space_before_colon_in_inheritance_clause = true
csharp_space_after_colon_in_inheritance_clause = true
csharp_space_around_binary_operators = before_and_after
csharp_space_between_method_declaration_parameter_list_parentheses = false
csharp_space_between_method_declaration_empty_parameter_list_parentheses = false
csharp_space_between_method_declaration_name_and_open_parenthesis = false
csharp_space_between_method_call_parameter_list_parentheses = false
csharp_space_between_method_call_empty_parameter_list_parentheses = false
csharp_space_between_method_call_name_and_opening_parenthesis = false
csharp_space_after_comma = true
csharp_space_before_comma = false
csharp_space_after_dot = false
csharp_space_before_dot = false
csharp_space_after_semicolon_in_for_statement = true
csharp_space_before_semicolon_in_for_statement = false
csharp_space_around_declaration_statements = false
csharp_space_before_open_square_brackets = false
csharp_space_between_empty_square_brackets = false
csharp_space_between_square_brackets = false

# Wrap options
csharp_preserve_single_line_blocks = true
csharp_preserve_single_line_statements = true

#### Naming styles ####

# Naming rules

dotnet_naming_rule.interface_should_be_begins_with_i.severity = suggestion
dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface
dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i

dotnet_naming_rule.types_should_be_pascal_case.severity = suggestion
dotnet_naming_rule.types_should_be_pascal_case.symbols = types
dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case

dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = suggestion
dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members
dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case

# Symbol specifications

dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.interface.required_modifiers =

dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum
dotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.types.required_modifiers =

dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method
dotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.non_field_members.required_modifiers =

# Naming styles

dotnet_naming_style.pascal_case.required_prefix =
dotnet_naming_style.pascal_case.required_suffix =
dotnet_naming_style.pascal_case.word_separator =
dotnet_naming_style.pascal_case.capitalization = pascal_case

dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.required_suffix =
dotnet_naming_style.begins_with_i.word_separator =
dotnet_naming_style.begins_with_i.capitalization = pascal_case


# CA1000: Do not declare static members on generic types
# When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does
# not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type
# argument is different and easily confused.
dotnet_diagnostic.CA1000.severity = warning

# CA1001: Types that own disposable fields should be disposable
# A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable. A class that
# declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.
dotnet_diagnostic.CA1001.severity = warning

# CA1002: Do not expose generic lists
# System.Collections.Generic.List<(Of <(T>)>) is a generic collection that is designed for performance, not inheritance. Therefore, List does
# not contain any virtual members. The generic collections that are designed for inheritance should be exposed instead.
dotnet_diagnostic.CA1002.severity = warning

# CA1003: Use generic event handler instances
# A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is
# assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.
dotnet_diagnostic.CA1003.severity = warning

# CA1004: Generic methods should provide type parameter
# Inference is how the type argument of a generic method is determined by the type of argument that is passed to the method, instead of by the
# explicit specification of the type argument. To enable inference, the parameter signature of a generic method must include a parameter that
# is of the same type as the type parameter for the method. In this case, the type argument does not have to be specified. When you use
# inference for all type parameters, the syntax for calling generic and nongeneric instance methods is identical; this simplifies the usability
# of generic methods.
dotnet_diagnostic.CA1004.severity = warning

# CA1005: Avoid excessive parameters on generic types
# The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents. It is
# usually obvious with one type parameter, as in List<T>, and in certain cases with two type parameters, as in Dictionary<TKey, TValue>.
# However, if more than two type parameters exist, the difficulty becomes too great for most users.
# Disable reason: Until Generics on Generics is implemented, we can't act upon this warning really. See https://github.com/dotnet/csharplang/issues/339.
dotnet_diagnostic.CA1005.severity = none

# CA1006: Do not nest generic types in member signatures
# A nested type argument is a type argument that is also a generic type. To call a member whose signature contains a nested type argument,
# the user must instantiate one generic type and pass this type to the constructor of a second generic type. The required procedure and syntax
# are complex and should be avoided.
dotnet_diagnostic.CA1006.severity = warning

# CA1007: Use generics where appropriate
# An externally visible method contains a reference parameter of type System.Object. Use of a generic method enables all types, subject to
# constraints, to be passed to the method without first casting the type to the reference parameter type.
dotnet_diagnostic.CA1007.severity = warning

# CA1008: Enums should have zero value
# The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags attributed enumeration should define a member
# by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute
# attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.
dotnet_diagnostic.CA1008.severity = warning

# CA1009: Declare event handlers correctly
# Event handler methods take two parameters. The first is of type System.Object and is named "sender". This is the object that raised the event.
# The second parameter is of type System.EventArgs and is named "e". This is the data that is associated with the event. Event handler methods
# should not return a value; in the C# programming language, this is indicated by the return type void.
dotnet_diagnostic.CA1009.severity = warning

# CA1010: Collections should implement generic interface
# To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate
# generic collection types.
dotnet_diagnostic.CA1010.severity = warning

# CA1011: Consider passing base types as parameters
# When a base type is specified as a parameter in a method declaration, any type that is derived from the base type can be passed as the
# corresponding argument to the method. If the additional functionality that is provided by the derived parameter type is not required, use of
# the base type enables wider use of the method.
dotnet_diagnostic.CA1011.severity = warning

# CA1012: Abstract types should not have constructors
# Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot
# create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.
dotnet_diagnostic.CA1012.severity = warning

# CA1013: Overload operator equals on overloading add and subtract
# A public or protected type implements the addition or subtraction operators without implementing the equality operator.
dotnet_diagnostic.CA1013.severity = warning

# CA1014: Mark assemblies with CLSCompliantAttribute
# The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be
# used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.
# If this attribute is not present on an assembly, the assembly is not compliant.
dotnet_diagnostic.CA1014.severity = warning

# CA1016: Mark assemblies with AssemblyVersionAttribute
# .NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used
# together with version and publisher policy. By default, applications run only with the assembly version with which they were built.
dotnet_diagnostic.CA1016.severity = warning

# CA1017: Mark assemblies with ComVisibleAttribute
# ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility.
# COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present,
# the contents of the assembly are visible to COM clients.
dotnet_diagnostic.CA1017.severity = warning

# CA1018: Mark attributes with AttributeUsageAttribute
# When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be
# applied. The meaning and intended usage of an attribute will determine its valid locations in code.
dotnet_diagnostic.CA1018.severity = warning

# CA1019: Define accessors for attribute arguments
# Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional
# arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also
# provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define
# optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have
# a corresponding read/write property.
dotnet_diagnostic.CA1019.severity = warning

# CA1020: Avoid namespaces with few types
# Make sure that each of your namespaces has a logical organization, and that you have a valid reason to put types in a sparsely populated
# namespace.
dotnet_diagnostic.CA1020.severity = warning

# CA1021: Avoid out parameters
# Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ,
# and handling methods with multiple return values. Also, the difference between out and ref parameters is not widely understood.
# Disable reason: We are OK to use out and ref.
dotnet_diagnostic.CA1021.severity = none

# CA1023: Indexers should not be multidimensional
# Indexers (that is, indexed properties) should use a single index. Multidimensional indexers can significantly reduce the usability of the
# library.
dotnet_diagnostic.CA1023.severity = warning

# CA1024: Use properties where appropriate
# A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array. The method
# might be a good candidate to become a property.
dotnet_diagnostic.CA1024.severity = warning

# CA1025: Replace repetitive arguments with params array
# Use a parameter array instead of repeated arguments when the exact number of arguments is unknown and when the variable arguments are the
# same type or can be passed as the same type.
dotnet_diagnostic.CA1025.severity = warning

# CA1026: Default parameters should not be used
# Methods that use default parameters are allowed under the CLS; however, the CLS lets compilers ignore the values that are assigned to these
# parameters. To maintain the behavior that you want across programming languages, methods that use default parameters should be replaced by
# method overloads that provide the default parameters.
dotnet_diagnostic.CA1026.severity = warning

# CA1027: Mark enums with FlagsAttribute
# An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants
# can be meaningfully combined.
dotnet_diagnostic.CA1027.severity = warning

# CA1028: Enum storage should be Int32
# An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the
# constant value. Even though you can change this underlying type, it is not required or recommended for most scenarios.
dotnet_diagnostic.CA1028.severity = warning

# CA1030: Use events where appropriate
# This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined
# state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the
# method directly.
dotnet_diagnostic.CA1030.severity = warning

# CA1031: Do not catch general exception types
# General exceptions should not be caught. Catch a more-specific exception, or rethrow the general exception as the last statement in the
# catch block.
# Disable reason: We do want to catch general exceptions when as we do not use exception propagation to higher levels. Instead we use result
# return values.
dotnet_diagnostic.CA1031.severity = none

# CA1032: Implement standard exception constructors
# Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.
dotnet_diagnostic.CA1032.severity = warning

# CA1033: Interface methods should be callable by child types
# An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative
# externally visible method that has the same name.
dotnet_diagnostic.CA1033.severity = warning

# CA1034: Nested types should not be visible
# A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details
# of the containing type. Used for this purpose, nested types should not be externally visible.
dotnet_diagnostic.CA1034.severity = warning

# CA1035: ICollection implementations have strongly typed members
# This rule requires ICollection implementations to provide strongly typed members so that users are not required to cast arguments to the
# Object type when they use the functionality that is provided by the interface. This rule assumes that the type that implements ICollection
# does so to manage a collection of instances of a type that is stronger than Object.
dotnet_diagnostic.CA1035.severity = warning

# CA1036: Override methods on comparable types
# A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the
# language-specific operator for equality, inequality, less than, or greater than.
dotnet_diagnostic.CA1036.severity = warning

# CA1038: Enumerators should be strongly typed
# This rule requires IEnumerator implementations to also provide a strongly typed version of the Current property so that users are not
# required to cast the return value to the strong type when they use the functionality that is provided by the interface.
dotnet_diagnostic.CA1038.severity = warning

# CA1039: Lists are strongly typed
# This rule requires IList implementations to provide strongly typed members so that users are not required to cast arguments to the
# System.Object type when they use the functionality that is provided by the interface.
dotnet_diagnostic.CA1039.severity = warning

# CA1040: Avoid empty interfaces
# Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted
# by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations
# for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be
# implemented.
# Disable reason: The alternative is to use C# attributes instead of empty interfaces. Empty interfaces do not have runtime performance penalty though.
dotnet_diagnostic.CA1040.severity = none

# CA1041: Provide ObsoleteAttribute message
# A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property
# specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed,
# which gives the user information about the obsolete type or member.
dotnet_diagnostic.CA1041.severity = warning

# CA1043: Use integral or string argument for indexers
# Indexers (that is, indexed properties) should use integral or string types for the index. These types are typically used for indexing data
# structures and they increase the usability of the library. Use of the Object type should be restricted to those cases where the specific
# integral or string type cannot be specified at design time.
dotnet_diagnostic.CA1043.severity = warning

# CA1044: Properties should not be write only
# Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.
# This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also,
# without read access, the state of shared objects cannot be viewed, which limits their usefulness.
dotnet_diagnostic.CA1044.severity = warning

# CA1045: Do not pass types by reference
# Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ,
# and handling methods with multiple return values. Library architects who design for a general audience should not expect users to master
# working with out or ref parameters.
# Disable reason: We only use references where necessary.
dotnet_diagnostic.CA1045.severity = none

# CA1046: Do not overload operator equals on reference types
# For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal
# only if they point to the same object.
dotnet_diagnostic.CA1046.severity = warning

# CA1047: Do not declare protected members in sealed types
# Types declare protected members so that inheriting types can access or override the member. By definition, sealed types cannot be inherited,
# which means that protected methods on sealed types cannot be called.
dotnet_diagnostic.CA1047.severity = warning

# CA1048: Do not declare virtual members in sealed types
# Types declare methods as virtual so that inheriting types can override the implementation of the virtual method. By definition, a sealed type
# cannot be inherited. This makes a virtual method on a sealed type meaningless.
dotnet_diagnostic.CA1048.severity = warning

# CA1049: Types that own native resources should be disposable
# Types that allocate unmanaged resources should implement IDisposable to enable callers to release those resources on demand and to shorten
# the lifetimes of the objects that hold the resources.
dotnet_diagnostic.CA1049.severity = warning

# CA1050: Declare types in namespaces
# Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.
dotnet_diagnostic.CA1050.severity = warning

# CA1051: Do not declare visible instance fields
# The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using
# properties.
dotnet_diagnostic.CA1051.severity = warning

# CA1052: Static holder types should be sealed
# A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic)
# modifier. A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.
dotnet_diagnostic.CA1052.severity = warning

# CA1053: Static holder types should not have constructors
# A public or nested public type declares only static members and has a public or protected default constructor. The constructor is
# unnecessary because calling static members does not require an instance of the type. The string overload should call the uniform resource
# identifier (URI) overload by using the string argument for safety and security.
dotnet_diagnostic.CA1053.severity = warning

# CA1054: URI parameters should not be strings
# If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class,
# which provides these services in a safe and secure manner.
dotnet_diagnostic.CA1054.severity = warning

# CA1055: URI return values should not be strings
# This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead
# to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.
dotnet_diagnostic.CA1055.severity = warning

# CA1056: URI properties should not be strings
# This rule assumes that the property represents a URI. A string representation of a URI is prone to parsing and encoding errors, and can
# lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.
dotnet_diagnostic.CA1056.severity = warning

# CA1057: String URI overloads call System.Uri overloads
# A type declares method overloads that differ only by the replacement of a string parameter with a System.Uri parameter. The overload that
# takes the string parameter does not call the overload that takes the URI parameter.
dotnet_diagnostic.CA1057.severity = warning

# CA1058: Types should not extend certain base types
# An externally visible type extends certain base types. Use one of the alternatives.
dotnet_diagnostic.CA1058.severity = warning

# CA1059: Members should not expose certain concrete types
# A concrete type is a type that has a complete implementation and therefore can be instantiated. To enable widespread use of the member,
# replace the concrete type by using the suggested interface.
dotnet_diagnostic.CA1059.severity = warning

# CA1060: Move P/Invokes to NativeMethods class
# Platform Invocation methods, such as those marked with the System.Runtime.InteropServices.DllImportAttribute or methods defined by using
# the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or
# UnsafeNativeMethods class.
dotnet_diagnostic.CA1060.severity = warning

# CA1061: Do not hide base class methods
# A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method
# differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.
dotnet_diagnostic.CA1061.severity = warning

# CA1062: Validate arguments of public methods
# All reference arguments that are passed to externally visible methods should be checked against null.
# Disable reason: CA1062 is not compatible with "nullable reference types" introduced in C# 8
# See: https://github.com/dotnet/roslyn-analyzers/issues/2875#issuecomment-536365776
dotnet_diagnostic.CA1062.severity = none

# CA1063: Implement IDisposable correctly
# All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = warning

# CA1064: Exceptions should be public
# An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base
# exception can be used to catch the exception. If the internal exception is inherited from System.Exception, System.SystemException, or
# System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.
dotnet_diagnostic.CA1064.severity = warning

# CA1065: Do not raise exceptions in unexpected locations
# A method that is not expected to throw exceptions throws an exception.
dotnet_diagnostic.CA1065.severity = warning

# CA1066: Implement IEquatable when overriding Equals
# A value type overrides Equals method, but does not implement IEquatable<T>.
dotnet_diagnostic.CA1066.severity = warning

# CA1067: Override Equals when implementing IEquatable
# A type implements IEquatable<T>, but does not override Equals method.
dotnet_diagnostic.CA1067.severity = warning

# CA1068: CancellationToken parameters must come last
# A method has a CancellationToken parameter that is not the last parameter.
dotnet_diagnostic.CA1068.severity = warning

# CA1069: Enums should not have duplicate values
# An enumeration has multiple members which are explicitly assigned the same constant value.
dotnet_diagnostic.CA1069.severity = warning

# CA1070: Do not declare event fields as virtual
# A field-like event was declared as virtual.
dotnet_diagnostic.CA1070.severity = warning

# CA1200: Avoid using cref tags with a prefix
# The cref attribute in an XML documentation tag means "code reference". It specifies that the inner text of the tag is a code element,
# such as a type, method, or property. Avoid using cref tags with prefixes, because it prevents the compiler from verifying references.
# It also prevents the Visual Studio integrated development environment (IDE) from finding and updating these symbol references during
# refactorings.
dotnet_diagnostic.CA1200.severity = warning

# CA1302: Do not hardcode locale specific strings
# The System.Environment.SpecialFolder enumeration contains members that refer to special system folders. The locations of these folders can
# have different values on different operating systems; the user can change some of the locations; and the locations are localized. The
# Environment.GetFolderPath method returns the locations that are associated with the Environment.SpecialFolder enumeration, localized,
# and appropriate for the currently running computer.
dotnet_diagnostic.CA1302.severity = warning

# CA1303: Do not pass literals as localized parameters
# An externally visible method passes a string literal as a parameter to a .NET constructor or method, and that string should be localizable.
# Disable reason: We want to be able to conveniently call NLog logging methods.
dotnet_diagnostic.CA1303.severity = none

# CA1304: Specify CultureInfo
# A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or
# constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not
# supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales.
dotnet_diagnostic.CA1304.severity = warning

# CA1305: Specify IFormatProvider
# A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or
# constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider
# object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales.
dotnet_diagnostic.CA1305.severity = warning
# Disable reason for NLog: We want to be able to conveniently call NLog logging methods.
dotnet_code_quality.CA1305.excluded_symbol_names = N:NLog*

# CA1306: Set locale for data types
# The locale determines culture-specific presentation elements for data, such as formatting that is used for numeric values, currency
# symbols, and sort order. When you create a DataTable or DataSet, you should explicitly set the locale.
dotnet_diagnostic.CA1306.severity = warning

# CA1307: Specify StringComparison
# A string comparison operation uses a method overload that does not set a StringComparison parameter.
dotnet_diagnostic.CA1307.severity = warning

# CA1308: Normalize strings to uppercase
# Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase.
dotnet_diagnostic.CA1308.severity = warning

# CA1309: Use ordinal StringComparison
# A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase.
# By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed,
# becomes more correct, and becomes more reliable.
dotnet_diagnostic.CA1309.severity = warning

# CA1400: P/Invoke entry points should exist
# A public or protected method is marked by using the System.Runtime.InteropServices.DllImportAttribute attribute. Either the unmanaged
#  library could not be located or the method could not be matched to a function in the library.
dotnet_diagnostic.CA1400.severity = warning

# CA1401: P/Invokes should not be visible
# A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the
# Declare keyword in Visual Basic). Such methods should not be exposed.
dotnet_diagnostic.CA1401.severity = warning

# CA1402: Avoid overloads in COM visible interfaces
# When overloaded methods are exposed to COM clients, only the first method overload retains its name. Subsequent overloads are uniquely
# renamed by appending to the name an underscore character (_) and an integer that corresponds to the order of declaration of the overload.
dotnet_diagnostic.CA1402.severity = warning

# CA1403: Auto layout types should not be COM visible
# A COM-visible value type is marked by using the System.Runtime.InteropServices.StructLayoutAttribute attribute set to LayoutKind.Auto. The
# layout of these types can change between .NET versions, which will break COM clients that expect a specific layout.
dotnet_diagnostic.CA1403.severity = warning

# CA1404: Call GetLastError immediately after P/Invoke
# A call is made to the Marshal.GetLastWin32Error method or the equivalent Win32 GetLastError function, and the immediately previous call is
# not to a platform invoke method.
dotnet_diagnostic.CA1404.severity = warning

# CA1405: COM visible type base types should be COM visible
# A COM-visible type derives from a type that is not COM-visible.
dotnet_diagnostic.CA1405.severity = warning

# CA1406: Avoid Int64 arguments for Visual Basic 6 clients
# Visual Basic 6 COM clients cannot access 64-bit integers.
dotnet_diagnostic.CA1406.severity = warning

# CA1407: Avoid static members in COM visible types
# COM does not support static methods.
dotnet_diagnostic.CA1407.severity = warning

# CA1408: Do not use AutoDual ClassInterfaceType
# Types that use a dual interface enable clients to bind to a specific interface layout. Any changes in a future version to the layout of the
# type or any base types will break COM clients that bind to the interface. By default, if the ClassInterfaceAttribute attribute is not
# specified, a dispatch-only interface is used.
dotnet_diagnostic.CA1408.severity = warning

# CA1409: Com visible types should be creatable
# A reference type that is specifically marked as visible to COM contains a public parameterized constructor but does not contain a public
# default (parameterless) constructor. A type without a public default constructor is not creatable by COM clients.
dotnet_diagnostic.CA1409.severity = warning

# CA1410: COM registration methods should be matched
# A type declares a method that is marked by using the System.Runtime.InteropServices.ComRegisterFunctionAttribute attribute but does not
# declare a method that is marked by using the System.Runtime.InteropServices.ComUnregisterFunctionAttribute attribute, or vice versa.
dotnet_diagnostic.CA1410.severity = warning

# CA1411: COM registration methods should not be visible
# A method that is marked by using the System.Runtime.InteropServices.ComRegisterFunctionAttribute attribute or the
# System.Runtime.InteropServices.ComUnregisterFunctionAttribute attribute is externally visible.
dotnet_diagnostic.CA1411.severity = warning

# CA1412: Mark ComSource Interfaces as IDispatch
# A type is marked by using the System.Runtime.InteropServices.ComSourceInterfacesAttribute attribute, and at least one of the specified
# interfaces is not marked by using the System.Runtime.InteropServices.InterfaceTypeAttribute attribute set to ComInterfaceType.InterfaceIsIDispatch.
dotnet_diagnostic.CA1412.severity = warning

# CA1413: Avoid non-public fields in COM visible value types
# Nonpublic instance fields of COM-visible value types are visible to COM clients. Review the content of the fields for information that
# should not be exposed, or that will have unintended design or security effects.
dotnet_diagnostic.CA1413.severity = warning

# CA1414: Mark boolean P/Invoke arguments with MarshalAs
# The Boolean data type has multiple representations in unmanaged code.
dotnet_diagnostic.CA1414.severity = warning

# CA1415: Declare P/Invokes correctly
# This rule looks for platform invoke method declarations that target Win32 functions that have a pointer to an OVERLAPPED structure parameter
# and the corresponding managed parameter is not a pointer to a System.Threading.NativeOverlapped structure.
dotnet_diagnostic.CA1415.severity = warning

# CA2101: Specify marshaling for P/Invoke string arguments
# A platform invoke member allows for partially trusted callers, has a string parameter, and does not explicitly marshal the string. This
# can cause a potential security vulnerability.
dotnet_diagnostic.CA2101.severity = warning

# CA1500: Variable names should not match field names
# An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, which leads to errors.
dotnet_diagnostic.CA1500.severity = warning

# CA1501: Avoid excessive inheritance
# A type is more than four levels deep in its inheritance hierarchy. Deeply nested type hierarchies can be difficult to follow, understand,
# and maintain.
dotnet_diagnostic.CA1501.severity = warning

# CA1502: Avoid excessive complexity
# This rule measures the number of linearly independent paths through the method, which is determined by the number and complexity of
# conditional branches.
dotnet_diagnostic.CA1502.severity = warning

# CA1504: Review misleading field names
# The name of an instance field starts with "s_", or the name of a static (Shared in Visual Basic) field starts with "m_".
dotnet_diagnostic.CA1504.severity = warning

# CA1505: Avoid unmaintainable code
# A type or method has a low maintainability index value. A low maintainability index indicates that a type or method is probably difficult
# to maintain and would be a good candidate for redesign.
dotnet_diagnostic.CA1505.severity = warning

# CA1506: Avoid excessive class coupling
# This rule measures class coupling by counting the number of unique type references that a type or method contains.
# Disable reason: This is shown for our Main method where we use DI.
dotnet_diagnostic.CA1506.severity = none

# CA1507: Use nameof in place of string
# A string literal is used as an argument where a nameof expression could be used.
dotnet_diagnostic.CA1507.severity = warning

# CA1508: Avoid dead conditional code
# A method has conditional code that always evaluates to true or false at runtime. This leads to dead code in the false branch of the condition.
dotnet_diagnostic.CA1508.severity = warning

# CA1509: Invalid entry in code metrics configuration file
# Code metrics rules, such as CA1501, CA1502, CA1505 and CA1506, supplied a configuration file named CodeMetricsConfig.txt that has an invalid
# entry.
dotnet_diagnostic.CA1509.severity = warning

# CA1600: Do not use idle process priority
# Do not set process priority to Idle. Processes that have System.Diagnostics.ProcessPriorityClass.Idle will occupy the CPU when it would
# otherwise be idle, and will therefore block standby.
dotnet_diagnostic.CA1600.severity = warning

# CA1601: Do not use timers that prevent power state changes
# Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.
dotnet_diagnostic.CA1601.severity = warning

# CA1700: Do not name enum values 'Reserved'
# This rule assumes that an enumeration member that has a name that contains "reserved" is not currently used but is a placeholder to be renamed
# or removed in a future version. Renaming or removing a member is a breaking change.
dotnet_diagnostic.CA1700.severity = warning

# CA1701: Resource string compound words should be cased correctly
# Each word in the resource string is split into tokens that are based on the casing. Each contiguous two-token combination is checked by the
# Microsoft spelling checker library. If recognized, the word produces a violation of the rule.
dotnet_diagnostic.CA1701.severity = warning

# CA1702: Compound words should be cased correctly
# The name of an identifier contains multiple words, and at least one of the words appears to be a compound word that is not cased correctly.
dotnet_diagnostic.CA1702.severity = warning

# CA1703: Resource strings should be spelled correctly
# A resource string contains one or more words that are not recognized by the Microsoft spelling checker library.
dotnet_diagnostic.CA1703.severity = warning

# CA1704: Identifiers should be spelled correctly
# The name of an externally visible identifier contains one or more words that are not recognized by the Microsoft spelling checker library.
dotnet_diagnostic.CA1704.severity = warning

# CA1707: Identifiers should not contain underscores
# By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.
dotnet_diagnostic.CA1707.severity = warning

# CA1708: Identifiers should differ by more than case
# Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime
# are not required to be case-sensitive.
# Disable reason: We use delegates and properties or fields with the same name except for casing.
dotnet_diagnostic.CA1708.severity = none

# CA1709: Identifiers should be cased correctly
# By convention, parameter names use camel casing, and namespace, type, and member names use Pascal casing.
dotnet_diagnostic.CA1709.severity = warning

# CA1710: Identifiers should have correct suffix
# By convention, the names of types that extend certain base types or that implement certain interfaces, or types derived from these types, have
# a suffix that is associated with the base type or interface.
dotnet_diagnostic.CA1710.severity = warning

# CA1711: Identifiers should not have incorrect suffix
# By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these
# types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.
dotnet_diagnostic.CA1711.severity = warning

# CA1712: Do not prefix enum values with type name
# Names of enumeration members are not prefixed with the type name because type information is expected to be provided by development tools.
dotnet_diagnostic.CA1712.severity = warning

# CA1713: Events should not have before or after prefix
# The name of an event starts with "Before" or "After". To name related events that are raised in a specific sequence, use the present or past
# tense to indicate the relative position in the sequence of actions.
dotnet_diagnostic.CA1713.severity = warning

# CA1714: Flags enums should have plural names
# A public enumeration has the System.FlagsAttribute attribute and its name does not end in "s". Types that are marked with FlagsAttribute have
# names that are plural because the attribute indicates that more than one value can be specified.
dotnet_diagnostic.CA1714.severity = warning

# CA1715: Identifiers should have correct prefix
# The name of an externally visible interface does not start with a capital "I". The name of a generic type parameter on an externally visible
# type or method does not start with a capital "T".
dotnet_diagnostic.CA1715.severity = warning

# CA1716: Identifiers should not match keywords
# A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match
# keywords that are defined by languages that target the common language runtime.
dotnet_diagnostic.CA1716.severity = warning

# CA1717: Only FlagsAttribute enums should have plural names
# Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the
# same time.
dotnet_diagnostic.CA1717.severity = warning

# CA1719: Parameter names should not match member names
# A parameter name should communicate the meaning of a parameter, and a member name should communicate the meaning of a member. It would be a rare
# design where these were the same. Naming a parameter the same as its member name is unintuitive and makes the library difficult to use.
dotnet_diagnostic.CA1719.severity = warning

# CA1720: Identifiers should not contain type names
# The name of a parameter in an externally visible member contains a data type name, or the name of an externally visible member contains a
# language-specific data type name.
dotnet_diagnostic.CA1720.severity = warning

# CA1721: Property names should not match get methods
# The name of a public or protected member starts with "Get" and otherwise matches the name of a public or protected property. "Get" methods and
# properties should have names that clearly distinguish their function.
dotnet_diagnostic.CA1721.severity = warning

# CA1722: Identifiers should not have incorrect prefix
# By convention, only certain programming elements have names that begin with a specific prefix.
dotnet_diagnostic.CA1722.severity = warning

# CA1724: Type Names Should Not Match Namespaces
# Type names should not match the names of .NET namespaces. Violation of this rule can reduce the usability of the library.
dotnet_diagnostic.CA1724.severity = warning

# CA1725: Parameter names should match base declaration
# Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method
# that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload
# of the method.
dotnet_diagnostic.CA1725.severity = warning

# CA1726: Use preferred terms
# The name of an externally visible identifier includes a term for which an alternative, preferred term exists. Alternatively, the name includes the
# term "Flag" or "Flags".
dotnet_diagnostic.CA1726.severity = warning

# CA1800: Do not cast unnecessarily
# Duplicate casts decrease performance, especially when the casts are performed in compact iteration statements.
dotnet_diagnostic.CA1800.severity = warning

# CA1801: Review unused parameters
# A method signature includes a parameter that is not used in the method body.
dotnet_diagnostic.CA1801.severity = warning

# CA1802: Use Literals Where Appropriate
# A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.
# Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic)
# field so that the value is computed at compile time instead of at run time.
dotnet_diagnostic.CA1802.severity = warning

# CA1804: Remove unused locals
# Unused local variables and unnecessary assignments increase the size of an assembly and decrease performance.
dotnet_diagnostic.CA1804.severity = warning

# CA1806: Do not ignore method results
# A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component
# Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.
dotnet_diagnostic.CA1806.severity = warning

# CA1809: Avoid excessive locals
# A common performance optimization is to store a value in a processor register instead of memory, which is referred to as "enregistering the value".
# To increase the chance that all local variables are enregistered, limit the number of local variables to 64.
dotnet_diagnostic.CA1809.severity = warning

# CA1810: Initialize reference type static fields inline
# When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of
# the type to make sure that the static constructor was previously called. Static constructor checks can decrease performance.
dotnet_diagnostic.CA1810.severity = warning

# CA1811: Avoid uncalled private code
# A private or internal (assembly-level) member does not have callers in the assembly, it is not invoked by the common language runtime, and it is not
# invoked by a delegate.
dotnet_diagnostic.CA1811.severity = warning

# CA1812: Avoid uninstantiated internal classes
# An instance of an assembly-level type is not created by code in the assembly.
dotnet_diagnostic.CA1812.severity = warning

# CA1813: Avoid unsealed attributes
# .NET provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute
# eliminates the search through the inheritance hierarchy and can improve performance.
dotnet_diagnostic.CA1813.severity = warning

# CA1814: Prefer jagged arrays over multidimensional
# A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, which can result in less wasted
# space for some sets of data.
dotnet_diagnostic.CA1814.severity = warning

# CA1815: Override equals and operator equals on value types
# For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is
# computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use
# instances as hash table keys, your value type should implement Equals.
dotnet_diagnostic.CA1815.severity = warning

# CA1816: Call GC.SuppressFinalize correctly
# A method that is an implementation of Dispose does not call GC.SuppressFinalize, or a method that is not an implementation of Dispose calls
# GC.SuppressFinalize, or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).
dotnet_diagnostic.CA1816.severity = warning

# CA1819: Properties should not return arrays
# Arrays that are returned by properties are not write-protected, even if the property is read-only. To keep the array tamper-proof, the property must
# return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.
dotnet_diagnostic.CA1819.severity = warning

# CA1820: Test for empty strings using string length
# Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.
dotnet_diagnostic.CA1820.severity = warning

# CA1821: Remove empty finalizers
# Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime. An empty finalizer
# incurs added overhead without any benefit.
dotnet_diagnostic.CA1821.severity = warning

# CA1822: Mark members as static
# Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as
# static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.
# Disable reason: We do not write performance critical applications so we do not need to change instance methods to static methods.
dotnet_diagnostic.CA1822.severity = none

# CA1823: Avoid unused private fields
# Private fields were detected that do not appear to be accessed in the assembly.
dotnet_diagnostic.CA1823.severity = warning

# CA1824: Mark assemblies with NeutralResourcesLanguageAttribute
# The NeutralResourcesLanguage attribute informs the ResourceManager of the language that was used to display the resources of a neutral culture for
# an assembly. This improves lookup performance for the first resource that you load and can reduce your working set.
dotnet_diagnostic.CA1824.severity = warning

# CA1825: Avoid zero-length array allocations
# Initializing a zero-length array leads to unnecessary memory allocation. Instead, use the statically allocated empty array instance by calling
# Array.Empty. The memory allocation is shared across all invocations of this method.
dotnet_diagnostic.CA1825.severity = warning

# CA1826: Use property instead of Linq Enumerable method
# Enumerable LINQ method was used on a type that supports an equivalent, more efficient property.
dotnet_diagnostic.CA1826.severity = warning

# CA1827: Do not use Count/LongCount when Any can be used
# Count or LongCount method was used where Any method would be more efficient.
dotnet_diagnostic.CA1827.severity = warning

# CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used
# CountAsync or LongCountAsync method was used where AnyAsync method would be more efficient.
dotnet_diagnostic.CA1828.severity = warning

# CA1829: Use Length/Count property instead of Enumerable.Count method
# Count LINQ method was used on a type that supports an equivalent, more efficient Length or Count property.
dotnet_diagnostic.CA1829.severity = warning

# CA1831: Use AsSpan instead of Range-based indexers for string when appropriate
# When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan<char> type, the method Substring will be used instead
# of Slice, which produces a copy of requested portion of the string.
dotnet_diagnostic.CA1831.severity = warning

# CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array
# When using a range-indexer on an array and implicitly assigning the value to a ReadOnlySpan<T> or ReadOnlyMemory<T> type, the method GetSubArray
# will be used instead of Slice, which produces a copy of requested portion of the array.
dotnet_diagnostic.CA1832.severity = warning

# CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array
# When using a range-indexer on an array and implicitly assigning the value to a Span<T> or Memory<T> type, the method GetSubArray will be used
# instead of Slice, which produces a copy of requested portion of the array.
dotnet_diagnostic.CA1833.severity = warning

# CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
# 'Stream' has a 'ReadAsync' overload that takes a 'Memory<Byte>' as the first argument, and a 'WriteAsync' overload that takes a
# 'ReadOnlyMemory<Byte>' as the first argument. Prefer calling the memory based overloads, which are more efficient.
dotnet_diagnostic.CA1835.severity = warning

# CA1836: Prefer IsEmpty over Count when available
# The 'Count' or 'Length' property or the 'Count<TSource>(IEnumerable<TSource>)'' extension method was used to determine whether or not the object 
# contains any items by comparing the value to 0 or 1, and the object has a more efficient 'IsEmpty' property that could be used instead.
dotnet_diagnostic.CA1836.severity = warning

# CA1837: Use Environment.ProcessId instead of Process.GetCurrentProcess().Id
# This rule locates calls to 'System.Diagnostics.Process.GetCurrentProcess().Id' and suggests using 'System.Environment.ProcessId' instead, 
# because it is more efficient.
dotnet_diagnostic.CA1837.severity = warning

# CA1841: Prefer Dictionary Contains methods
# This rule locates calls to a 'Contains' method on the 'Keys' or 'Values' collection of an 'IDictionary<TKey,TValue>' that could be replaced with 
# a call to a 'ContainsKey' or 'ContainsValue' method on the dictionary itself.
dotnet_diagnostic.CA1841.severity = warning

# CA1845: Use span-based 'string.Concat'
# This rule locates string-concatenation expressions that contain 'Substring' calls and suggests replacing 'Substring' with 'AsSpan' 
# and using the span-based overload of 'String.Concat'.
dotnet_diagnostic.CA1845.severity = warning

# CA1846: Use string.Contains(char) instead of string.Contains(string) with single characters
# The result of a call to one of the String.Substring overloads is passed to a method with an available overload that accepts 'ReadOnlySpan<Char>'.
dotnet_diagnostic.CA1846.severity = warning

# CA1847: Prefer AsSpan over Substring
# 'string.Contains(string)' is used when 'string.Contains(char)' was available.
dotnet_diagnostic.CA1847.severity = warning

# CA1861: Avoid constant arrays as arguments
# A constant array of literal values is passed to a method via regular invocation or extension method invocation.
# Disable reason: We perform these optimizations where we see it as necessary. Especially in tests, we don't find it worth it.
dotnet_diagnostic.CA1861.severity = silent

# CA1900: Value type fields should be portable
# This rule checks that structures that are declared by using an explicit layout attribute will align correctly when marshaled to unmanaged code
# on 64-bit operating systems.
dotnet_diagnostic.CA1900.severity = warning

# CA1901: P/Invoke declarations should be portable
# This rule evaluates the size of each parameter and the return value of a P/Invoke, and verifies that their size is correct when marshaled to
# unmanaged code on 32-bit and 64-bit operating systems.
dotnet_diagnostic.CA1901.severity = warning

# CA1903: Use only API from targeted framework
# A member or type is using a member or type that was introduced in a service pack that was not included together with the targeted framework of
# the project.
dotnet_diagnostic.CA1903.severity = warning

# CA2000: Dispose objects before losing scope
# Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed
# before all references to it are out of scope.
dotnet_diagnostic.CA2000.severity = warning

# CA2001: Avoid calling problematic methods
# A member calls a potentially dangerous or problematic method.
dotnet_diagnostic.CA2001.severity = warning

# CA2002: Do not lock on objects with weak identity
# An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire
# a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.
dotnet_diagnostic.CA2002.severity = warning

# CA2003: Do not treat fibers as threads
# A managed thread is being treated as a Win32 thread.
dotnet_diagnostic.CA2003.severity = warning

# CA2004: Remove calls to GC.KeepAlive
# If you are converting to SafeHandle usage, remove all calls to GC.KeepAlive (object). In this case, classes should not have to call GC.KeepAlive,
# assuming they do not have a finalizer but rely on SafeHandle to finalize the OS handle for them.
dotnet_diagnostic.CA2004.severity = warning

# CA2006: Use SafeHandle to encapsulate native resources
# Use of IntPtr in managed code might indicate a potential security and reliability problem. All uses of IntPtr must be reviewed to determine whether
# use of a SafeHandle, or similar technology, is required in its place.
dotnet_diagnostic.CA2006.severity = warning

# CA2007: Do not directly await a Task
# An asynchronous method awaits a Task directly.
# Disable reason: CA2007 does not play well with CA2000. See also https://github.com/dotnet/roslyn-analyzers/issues/5530.
dotnet_diagnostic.CA2007.severity = none

# CA2009: Do not call ToImmutableCollection on an ImmutableCollection value
# ToImmutable method was unnecessarily called on an immutable collection from System.Collections.Immutable namespace.
dotnet_diagnostic.CA2009.severity = warning

# CA2011: Do not assign property within its setter
# A property was accidentally assigned a value within its own set accessor.
dotnet_diagnostic.CA2011.severity = warning

# CA2012: Use ValueTasks correctly
# A ValueTask instance returned from a member invocation is used in a way that could lead to exceptions, corruption, or poor performance.
dotnet_diagnostic.CA2012.severity = warning

# CA2013: Do not use ReferenceEquals with value types
# When comparing values using System.Object.ReferenceEquals, if objA and objB are value types, they are boxed before they are passed to the
# ReferenceEquals method. This means that even if both objA and objB represent the same instance of a value type, the ReferenceEquals method
# nevertheless returns false.
dotnet_diagnostic.CA2013.severity = warning

# CA2014: Do not use stackalloc in loops.
# Stack space allocated by a stackalloc is only released at the end of the current method's invocation. Using it in a loop can result in unbounded
# stack growth and eventual stack overflow conditions.
dotnet_diagnostic.CA2014.severity = warning

# CA2015: Do not define finalizers for types derived from MemoryManager<T>
# Adding a finalizer to a type derived from MemoryManager<T> may permit memory to be freed while it is still in use by a Span<T>.
dotnet_diagnostic.CA2015.severity = warning

# CA2016: Forward the 'CancellationToken' parameter to methods that take one
# This rule locates method invocations that could accept a CancellationToken parameter, but are not passing any, and suggests to forward the parent 
# method's CancellationToken to them.
dotnet_diagnostic.CA2016.severity = warning

# CA2018: The 'count' argument to 'Buffer.BlockCopy' should specify the number of bytes to copy
# This rule fires when 'Array.Length' is used for the 'count' argument of 'Buffer.BlockCopy' on arrays whose elements are larger than one byte in size.
dotnet_diagnostic.CA2018.severity = warning

# CA2100: Review SQL queries for security vulnerabilities
# A method sets the System.Data.IDbCommand.CommandText property by using a string that is built from a string argument to the method. This rule assumes
# that the string argument contains user input. A SQL command string built from user input is vulnerable to SQL injection attacks.
dotnet_diagnostic.CA2100.severity = warning

# CA2102: Catch non-CLSCompliant exceptions in general handlers
# A member in an assembly that is not marked with the RuntimeCompatibilityAttribute or is marked RuntimeCompatibility(WrapNonExceptionThrows = false)
# contains a catch block that handles System.Exception and does not contain an immediately following general catch block.
dotnet_diagnostic.CA2102.severity = warning

# CA2103: Review imperative security
# A method uses imperative security and might be constructing the permission by using state information or return values that can change while the
# demand is active. Use declarative security whenever possible.
dotnet_diagnostic.CA2103.severity = warning

# CA2104: Do not declare read only mutable reference types
# An externally visible type contains an externally visible read-only field that is a mutable reference type. A mutable type is a type whose instance
# data can be modified.
dotnet_diagnostic.CA2104.severity = warning

# CA2105: Array fields should not be read only
# When you apply the read-only (ReadOnly in Visual Basic) modifier to a field that contains an array, the field cannot be changed to reference a
# different array. However, the elements of the array stored in a read-only field can be changed.
dotnet_diagnostic.CA2105.severity = warning

# CA2106: Secure asserts
# A method asserts a permission and no security checks are performed on the caller. Asserting a security permission without performing any security
# checks can leave an exploitable security weakness in your code.
dotnet_diagnostic.CA2106.severity = warning

# CA2107: Review deny and permit only usage
# Using the PermitOnly method and CodeAccessPermission.Deny security actions should be used only by those with an advanced knowledge of .NET security.
# Code that uses these security actions should undergo a security review.
dotnet_diagnostic.CA2107.severity = warning

# CA2108: Review declarative security on value types
# A public or protected value type is secured by Data Access or Link Demands.
dotnet_diagnostic.CA2108.severity = warning

# CA2109: Review visible event handlers
# A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.
# Disable reason: This rule has been deprecated. See https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2109.
dotnet_diagnostic.CA2109.severity = none

# CA2111: Pointers should not be visible
# A pointer is not private, internal, or read-only. Malicious code can change the value of the pointer, potentially allowing access to arbitrary
# locations in memory or causing application or system failures.
dotnet_diagnostic.CA2111.severity = warning

# CA2112: Secured types should not expose fields
# A public or protected type contains public fields and is secured by Link Demands. If code has access to an instance of a type that is secured by
# a link demand, the code does not have to satisfy the link demand to access the type's fields.
dotnet_diagnostic.CA2112.severity = warning

# CA2114: Method security should be a superset of type
# A method should not have both method-level and type-level declarative security for the same action.
dotnet_diagnostic.CA2114.severity = warning

# CA2115: Call GC.KeepAlive when using native resources
# This rule detects errors that might occur because an unmanaged resource is being finalized while it is still being used in unmanaged code.
dotnet_diagnostic.CA2115.severity = warning

# CA2116: APTCA methods should only call APTCA methods
# When the APTCA (AllowPartiallyTrustedCallers) attribute is present on a fully trusted assembly, and the assembly executes code in another assembly
# that does not allow partially trusted callers, a security exploit is possible.
dotnet_diagnostic.CA2116.severity = warning

# CA2117: APTCA types should only extend APTCA base types
# When the APTCA (AllowPartiallyTrustedCallers) attribute is present on a fully trusted assembly, and a type in the assembly inherits from a type
# that does not allow partially trusted callers, a security exploit is possible.
dotnet_diagnostic.CA2117.severity = warning

# CA2118: Review SuppressUnmanagedCodeSecurityAttribute usage
# SuppressUnmanagedCodeSecurityAttribute changes the default security system behavior for members that execute unmanaged code that uses COM interop
# or platform invocation. This attribute is primarily used to increase performance; however, the performance gains come with significant security
# risks.
dotnet_diagnostic.CA2118.severity = warning

# CA2119: Seal methods that satisfy private interfaces
# An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of
# this rule, prevent the method from being overridden outside the assembly.
dotnet_diagnostic.CA2119.severity = warning

# CA2120: Secure serialization constructors
# This type has a constructor that takes a System.Runtime.Serialization.SerializationInfo object and a System.Runtime.Serialization.StreamingContext
# object (the signature of the serialization constructor). This constructor is not secured by a security check, but one or more of the regular
# constructors in the type are secured.
dotnet_diagnostic.CA2120.severity = warning

# CA2121: Static constructors should be private
# The system calls the static constructor before the first instance of the type is created or any static members are referenced. If a static
# constructor is not private, it can be called by code other than the system. Depending on the operations that are performed in the constructor,
# this can cause unexpected behavior.
dotnet_diagnostic.CA2121.severity = warning

# CA2122: Do not indirectly expose methods with link demands
# A public or protected member has Link Demands and is called by a member that does not perform any security checks. A link demand checks the
# permissions of the immediate caller only.
dotnet_diagnostic.CA2122.severity = warning

# CA2123: Override link demands should be identical to base
# This rule matches a method to its base method, which is either an interface or a virtual method in another type, and then compares the link
# demands on each. If this rule is violated, a malicious caller can bypass the link demand just by calling the unsecured method.
dotnet_diagnostic.CA2123.severity = warning

# CA2124: Wrap vulnerable finally clauses in outer try
# A public or protected method contains a try/finally block. The finally block appears to reset the security state and is not itself enclosed in
# a finally block.
dotnet_diagnostic.CA2124.severity = warning

# CA2126: Type link demands require inheritance demands
# A public unsealed type is protected with a link demand and has an overridable method. Neither the type nor the method is protected with an
# inheritance demand.
dotnet_diagnostic.CA2126.severity = warning

# CA2130: Security critical constants should be transparent
# Transparency enforcement is not enforced for constant values because compilers inline constant values so that no lookup is required at run
# time. Constant fields should be security transparent so that code reviewers do not assume that transparent code cannot access the constant.
dotnet_diagnostic.CA2130.severity = warning

# CA2131: Security critical types may not participate in type equivalence
# A type participates in type equivalence and either the type itself, or a member or field of the type, is marked with the
# SecurityCriticalAttribute attribute. This rule fires on any critical types or types that contain critical methods or fields that are
# participating in type equivalence. When the CLR detects such a type, it fails to load it with a TypeLoadException at run time. Typically,
# this rule fires only when users implement type equivalence manually rather than by relying on tlbimp and the compilers to do the type
# equivalence.
dotnet_diagnostic.CA2131.severity = warning

# CA2132: Default constructors must be at least as critical as base type default constructors
# Types and members that have the SecurityCriticalAttribute cannot be used by Silverlight application code. Security-critical types and members
# can be used only by trusted code in the .NET Framework for Silverlight class library. Because a public or protected construction in a derived
# class must have the same or greater transparency than its base class, a class in an application cannot be derived from a class marked
# SecurityCritical.
dotnet_diagnostic.CA2132.severity = warning

# CA2133: Delegates must bind to methods with consistent transparency
# This warning fires on a method that binds a delegate that is marked with the SecurityCriticalAttribute to a method that is transparent or that
# is marked with the SecuritySafeCriticalAttribute. The warning also fires a method that binds a delegate that is transparent or safe-critical
# to a critical method.
dotnet_diagnostic.CA2133.severity = warning

# CA2134: Methods must keep consistent transparency when overriding base methods
# This rule fires when a method marked with the SecurityCriticalAttribute overrides a method that is transparent or marked with the
# SecuritySafeCriticalAttribute. The rule also fires when a method that is transparent or marked with the SecuritySafeCriticalAttribute
# overrides a method that is marked with a SecurityCriticalAttribute. The rule is applied when overriding a virtual method or implementing an
# interface.
dotnet_diagnostic.CA2134.severity = warning

# CA2135: Level 2 assemblies should not contain LinkDemands
# LinkDemands are deprecated in the level 2 security rule set. Instead of using LinkDemands to enforce security at just-in-time (JIT) compilation
# time, mark the methods, types, and fields with the SecurityCriticalAttribute attribute.
dotnet_diagnostic.CA2135.severity = warning

# CA2136: Members should not have conflicting transparency annotations
# Transparency attributes are applied from code elements of larger scope to elements of smaller scope. The transparency attributes of code
# elements with larger scope take precedence over transparency attributes of code elements that are contained in the first element. For example,
# a class that is marked with the SecurityCriticalAttribute attribute cannot contain a method that is marked with the
# SecuritySafeCriticalAttribute attribute.
dotnet_diagnostic.CA2136.severity = warning

# CA2137: Transparent methods must contain only verifiable IL
# A method contains unverifiable code or returns a type by reference. This rule fires on attempts by security transparent code to execute
# unverifiable MSIL (Microsoft Intermediate Language). However, the rule does not contain a full IL verifier, and instead uses heuristics to
# catch most violations of MSIL verification.
dotnet_diagnostic.CA2137.severity = warning

# CA2138: Transparent methods must not call methods with the SuppressUnmanagedCodeSecurity attribute
# A security transparent method calls a method that is marked with the SuppressUnmanagedCodeSecurityAttribute attribute.
dotnet_diagnostic.CA2138.severity = warning

# CA2139: Transparent methods may not use the HandleProcessCorruptingExceptions attribute
# This rule fires on any method that's transparent and attempts to handle a process corrupting exception by using the
# HandleProcessCorruptedStateExceptionsAttribute attribute. A process corrupting exception is a CLR version 4.0 exception classification of
# exceptions such as AccessViolationException. The HandleProcessCorruptedStateExceptionsAttribute attribute may only be used by security
# critical methods, and will be ignored if it is applied to a transparent method.
dotnet_diagnostic.CA2139.severity = warning

# CA2140: Transparent code must not reference security critical items
# Methods that are marked with SecurityTransparentAttribute call non-public members that are marked as SecurityCritical. This rule analyzes all
# methods and types in an assembly that is mixed transparent and critical, and flags any calls from transparent code to non-public critical code
# that are not marked SecurityTreatAsSafe.
dotnet_diagnostic.CA2140.severity = warning

# CA2141: Transparent methods must not satisfy LinkDemands
# A security transparent method calls a method in an assembly that is not marked with the AllowPartiallyTrustedCallersAttribute (APTCA)
# attribute, or a security transparent method satisfies a LinkDemand for a type or a method.
dotnet_diagnostic.CA2141.severity = warning

# CA2142: Transparent code should not be protected with LinkDemands
# This rule fires on transparent methods which require LinkDemands to access them. Security transparent code should not be responsible for
# verifying the security of an operation, and therefore should not demand permissions.
dotnet_diagnostic.CA2142.severity = warning

# CA2143: Transparent methods should not use security demands
# Security transparent code should not be responsible for verifying the security of an operation, and therefore should not demand permissions.
# Security transparent code should use full demands to make security decisions and safe-critical code should not rely on transparent code to
# have made the full demand.
dotnet_diagnostic.CA2143.severity = warning

# CA2144: Transparent code should not load assemblies from byte arrays
# The security review for transparent code is not as thorough as the security review for critical code, because transparent code cannot perform
# security sensitive actions. Assemblies loaded from a byte array might not be noticed in transparent code, and that byte array might contain
# critical, or more importantly safe-critical code, that does need to be audited.
dotnet_diagnostic.CA2144.severity = warning

# CA2145: Transparent methods should not be decorated with the SuppressUnmanagedCodeSecurityAttribute
# Methods decorated with the SuppressUnmanagedCodeSecurityAttribute attribute have an implicit LinkDemand placed upon any method that calls it.
# This LinkDemand requires that the calling code be security critical. Marking the method that uses SuppressUnmanagedCodeSecurity with the
# SecurityCriticalAttribute attribute makes this requirement more obvious for callers of the method.
dotnet_diagnostic.CA2145.severity = warning

# CA2146: Types must be at least as critical as their base types and interfaces
# This rule fires when a derived type has a security transparency attribute that is not as critical as its base type or implemented interface.
# Only critical types can derive from critical base types or implement critical interfaces, and only critical or safe-critical types can derive
# from safe-critical base types or implement safe-critical interfaces.
dotnet_diagnostic.CA2146.severity = warning

# CA2147: Transparent methods may not use security asserts
# This rule analyzes all methods and types in an assembly that is either 100% transparent or mixed transparent/critical, and flags any
# declarative or imperative use of Assert.
dotnet_diagnostic.CA2147.severity = warning

# CA2149: Transparent methods must not call into native code
# This rule fires on any transparent method that calls directly into native code, for example, through a P/Invoke. Violations of this rule lead
# to a MethodAccessException in the level 2 transparency model, and a full demand for UnmanagedCode in the level 1 transparency model.
dotnet_diagnostic.CA2149.severity = warning

# CA2151: Fields with critical types should be security critical
# To use security critical types, the code that references the type must be either security critical or security safe critical. This is true
# even if the reference is indirect. Therefore, having a security transparent or security safe critical field is misleading because transparent
# code will still be unable to access the field.
dotnet_diagnostic.CA2151.severity = warning

# CA2153: Avoid Handling Corrupted State Exceptions
# Corrupted State Exceptions (CSE) indicate that memory corruption exists in your process. Catching these rather than allowing the process to
# crash can lead to security vulnerabilities if an attacker can place an exploit into the corrupted memory region.
dotnet_diagnostic.CA2153.severity = warning


# CA2200: Rethrow to preserve stack details
# An exception is rethrown and the exception is explicitly specified in the throw statement. If an exception is rethrown by specifying the
# exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.
dotnet_diagnostic.CA2200.severity = warning

# CA2201: Do not raise reserved exception types
# This makes the original error hard to detect and debug.
dotnet_diagnostic.CA2201.severity = warning

# CA2202: Do not dispose objects multiple times
# A method implementation contains code paths that could cause multiple calls to System.IDisposable.Dispose or a Dispose equivalent (such as
# a Close() method on some types) on the same object.
dotnet_diagnostic.CA2202.severity = warning

# CA2204: Literals should be spelled correctly
# A literal string in a method body contains one or more words that are not recognized by the Microsoft spelling checker library.
dotnet_diagnostic.CA2204.severity = warning

# CA2205: Use managed equivalents of Win32 API
# A platform invoke method is defined and a .NET method with the equivalent functionality is available.
dotnet_diagnostic.CA2205.severity = warning

# CA2207: Initialize value type static fields inline
# A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and
# remove the static constructor.
dotnet_diagnostic.CA2207.severity = warning

# CA2208: Instantiate argument exceptions correctly
# A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect
# string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.
dotnet_diagnostic.CA2208.severity = warning

# CA2211: Non-constant fields should not be visible
# Static fields that are not constants or read-only are not thread-safe. Access to such a field must be carefully controlled and requires
# advanced programming techniques for synchronizing access to the class object.
dotnet_diagnostic.CA2211.severity = warning

# CA2212: Do not mark serviced components with WebMethod
# A method in a type that inherits from System.EnterpriseServices.ServicedComponent is marked with System.Web.Services.WebMethodAttribute.
# Because WebMethodAttribute and a ServicedComponent method have conflicting behavior and requirements for context and transaction flow, the
# behavior of the method will be incorrect in some scenarios.
dotnet_diagnostic.CA2212.severity = warning

# CA2213: Disposable fields should be disposed
# A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field
# is not called by the Dispose method of the declaring type.
dotnet_diagnostic.CA2213.severity = warning

# CA2214: Do not call overridable methods in constructors
# When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.
dotnet_diagnostic.CA2214.severity = warning

# CA2215: Dispose methods should call base class dispose
# If a type inherits from a disposable type, it must call the Dispose method of the base type from its own Dispose method.
dotnet_diagnostic.CA2215.severity = warning

# CA2216: Disposable types should declare finalizer
# A type that implements System.IDisposable, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as
# described by Object.Finalize.
dotnet_diagnostic.CA2216.severity = warning

# CA2217: Do not mark enums with FlagsAttribute
# An externally visible enumeration is marked with FlagsAttribute, and it has one or more values that are not powers of two or a combination
# of the other defined values on the enumeration.
dotnet_diagnostic.CA2217.severity = warning

# CA2218: Override GetHashCode on overriding Equals
# GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table.
# Two objects that are the same type and are equal must return the same hash code.
dotnet_diagnostic.CA2218.severity = warning

# CA2219: Do not raise exceptions in exception clauses
# When an exception is raised in a finally or fault clause, the new exception hides the active exception. When an exception is raised in a filter
# clause, the run time silently catches the exception. This makes the original error hard to detect and debug.
dotnet_diagnostic.CA2219.severity = warning

# CA2220: Finalizers should call base class finalizer
# Finalization must be propagated through the inheritance hierarchy. To guarantee this, types must call their base class Finalize method in their
# own Finalize method.
dotnet_diagnostic.CA2220.severity = warning

# CA2221: Finalizers should be protected
# Finalizers must use the family access modifier.
dotnet_diagnostic.CA2221.severity = warning

# CA2222: Do not decrease inherited member visibility
# Don't change the access modifier for inherited members. Changing an inherited member to private does not prevent callers from accessing the
# base class implementation of the method.
dotnet_diagnostic.CA2222.severity = warning

# CA2223: Members should differ by more than return type
# Although the common language runtime allows the use of return types to differentiate between otherwise identical members, this feature is not
# in the Common Language Specification, nor is it a common feature of .NET programming languages.
dotnet_diagnostic.CA2223.severity = warning

# CA2224: Override equals on overloading operator equals
# A public type implements the equality operator, but does not override Object.Equals.
dotnet_diagnostic.CA2224.severity = warning

# CA2225: Operator overloads have named alternates
# An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to
# the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.
# Disable reason: We do not support other languages.
dotnet_diagnostic.CA2225.severity = none

# CA2226: Operators should have symmetrical overloads
# A type implements the equality or inequality operator, and does not implement the opposite operator.
dotnet_diagnostic.CA2226.severity = warning

# CA2227: Collection properties should be read only
# A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection
# from being replaced but still allows the individual members to be set.
dotnet_diagnostic.CA2227.severity = warning

# CA2228: Do not ship unreleased resource formats
# Resource files that were built by using pre-release versions of the .NET might not be usable by supported versions of .NET.
dotnet_diagnostic.CA2228.severity = warning

# CA2229: Implement serialization constructors
# To fix a violation of this rule, implement the serialization constructor. For a sealed class, make the constructor private; otherwise, make it
# protected.
dotnet_diagnostic.CA2229.severity = warning

# CA2230: Use params for variable arguments
# A public or protected type contains a public or protected method that uses the VarArgs calling convention instead of the params keyword.
dotnet_diagnostic.CA2230.severity = warning

# CA2231: Overload operator equals on overriding ValueType.Equals
# A value type overrides Object.Equals but does not implement the equality operator.
dotnet_diagnostic.CA2231.severity = warning

# CA2232: Mark Windows Forms entry points with STAThread
# STAThreadAttribute indicates that the COM threading model for the application is a single-threaded apartment. This attribute must be present
# on the entry point of any application that uses Windows Forms; if it is omitted, the Windows components might not work correctly.
dotnet_diagnostic.CA2232.severity = warning

# CA2233: Operations should not overflow
# Arithmetic operations should not be performed without first validating the operands, to make sure that the result of the operation is not
# outside the range of possible values for the data types involved.
dotnet_diagnostic.CA2233.severity = warning

# CA2234: Pass System.Uri objects instead of strings
# A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type
# of the method contains a corresponding method overload that has a System.Uri parameter.
dotnet_diagnostic.CA2234.severity = warning

# CA2235: Mark all non-serializable fields
# An instance field of a type that is not serializable is declared in a type that is serializable.
dotnet_diagnostic.CA2235.severity = warning

# CA2236: Call base class methods on ISerializable types
# To fix a violation of this rule, call the base type GetObjectData method or serialization constructor from the corresponding derived type
# method or constructor.
dotnet_diagnostic.CA2236.severity = warning

# CA2237: Mark ISerializable types with SerializableAttribute
# To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type
# uses a custom serialization routine through implementation of the ISerializable interface.
dotnet_diagnostic.CA2237.severity = warning

# CA2238: Implement serialization methods correctly
# A method that handles a serialization event does not have the correct signature, return type, or visibility.
dotnet_diagnostic.CA2238.severity = warning

# CA2239: Provide deserialization methods for optional fields
# A type has a field that is marked with the System.Runtime.Serialization.OptionalFieldAttribute attribute, and the type does not provide
# de-serialization event handling methods.
dotnet_diagnostic.CA2239.severity = warning

# CA2240: Implement ISerializable correctly
# To fix a violation of this rule, make the GetObjectData method visible and overridable, and make sure that all instance fields are included in
# the serialization process or explicitly marked with the NonSerializedAttribute attribute.
dotnet_diagnostic.CA2240.severity = warning

# CA2241: Provide correct arguments to formatting methods
# The format argument passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.
dotnet_diagnostic.CA2241.severity = warning

# CA2242: Test for NaN correctly
# This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.
dotnet_diagnostic.CA2242.severity = warning

# CA2243: Attribute string literals should parse correctly
# An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.
dotnet_diagnostic.CA2243.severity = warning

# CA2244: Do not duplicate indexed element initializations
# An object initializer has more than one indexed element initializer with the same constant index. All but the last initializer are redundant.
dotnet_diagnostic.CA2244.severity = warning

# CA2245: Do not assign a property to itself
# A property was accidentally assigned to itself.
dotnet_diagnostic.CA2245.severity = warning

# CA2246: Do not assign a symbol and its member in the same statement
# Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended. It is not clear if the member
# access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.
dotnet_diagnostic.CA2246.severity = warning

# CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'
# The enum type passed as an argument to the HasFlag method call is different from the calling enum type.
dotnet_diagnostic.CA2248.severity = warning


# CA2210: Assemblies should have valid strong names
# The strong name protects clients from unknowingly loading an assembly that has been tampered with. Assemblies without strong names should
# not be deployed outside very limited scenarios. If you share or distribute assemblies that are not correctly signed, the assembly can be
# tampered with, the common language runtime might not load the assembly, or the user might have to disable verification on his or her
# computer.
dotnet_diagnostic.CA2210.severity = warning

# CA2300: Do not use insecure deserializer BinaryFormatter
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2300.severity = warning

# CA2301: Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2301.severity = warning

# CA2302: Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2302.severity = warning

# CA2305: Do not use insecure deserializer LosFormatter
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2305.severity = warning

# CA2310: Do not use insecure deserializer NetDataContractSerializer
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2310.severity = warning

# CA2311: Do not deserialize without first setting NetDataContractSerializer.Binder
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2311.severity = warning

# CA2312: Ensure NetDataContractSerializer.Binder is set before deserializing
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2312.severity = warning

# CA2315: Do not use insecure deserializer ObjectStateFormatter
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2315.severity = warning

# CA2321: Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2321.severity = warning

# CA2322: Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2322.severity = warning

# CA2326: Do not use TypeNameHandling values other than None
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2326.severity = warning

# CA2327: Do not use insecure JsonSerializerSettings
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2327.severity = warning

# CA2328: Ensure that JsonSerializerSettings are secure
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2328.severity = warning

# CA2329: Do not deserialize with JsonSerializer using an insecure configuration
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2329.severity = warning

# CA2330: Ensure that JsonSerializer has a secure configuration when deserializing
# Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected
# types to inject objects with malicious side effects.
dotnet_diagnostic.CA2330.severity = warning

# CA3001: Review code for SQL injection vulnerabilities
# When working with untrusted input and SQL commands, be mindful of SQL injection attacks. An SQL injection attack can execute malicious SQL
# commands, compromising the security and integrity of your application.
dotnet_diagnostic.CA3001.severity = warning

# CA3002: Review code for XSS vulnerabilities
# When working with untrusted input from web requests, be mindful of cross-site scripting (XSS) attacks. An XSS attack injects untrusted input
# into raw HTML output, allowing the attacker to execute malicious scripts or maliciously modify content in your web page.
dotnet_diagnostic.CA3002.severity = warning

# CA3003: Review code for file path injection vulnerabilities
# When working with untrusted input from web requests, be mindful of using user-controlled input when specifying paths to files.
dotnet_diagnostic.CA3003.severity = warning

# CA3004: Review code for information disclosure vulnerabilities
# Disclosing exception information gives attackers insight into the internals of your application, which can help attackers find other
# vulnerabilities to exploit.
dotnet_diagnostic.CA3004.severity = warning

# CA3006: Review code for process command injection vulnerabilities
# When working with untrusted input, be mindful of command injection attacks. A command injection attack can execute malicious commands on
# the underlying operating system, compromising the security and integrity of your server.
dotnet_diagnostic.CA3006.severity = warning

# CA3007: Review code for open redirect vulnerabilities
# When working with untrusted input, be mindful of open redirect vulnerabilities. An attacker can exploit an open redirect vulnerability to
# use your website to give the appearance of a legitimate URL, but redirect an unsuspecting visitor to a phishing or other malicious webpage.
dotnet_diagnostic.CA3007.severity = warning

# CA3008: Review code for XPath injection vulnerabilities
# When working with untrusted input, be mindful of XPath injection attacks. Constructing XPath queries using untrusted input may allow an
# attacker to maliciously manipulate the query to return an unintended result, and possibly disclose the contents of the queried XML.
dotnet_diagnostic.CA3008.severity = warning

# CA3009: Review code for XML injection vulnerabilities
# When working with untrusted input, be mindful of XML injection attacks.
dotnet_diagnostic.CA3009.severity = warning

# CA3010: Review code for XAML injection vulnerabilities
# When working with untrusted input, be mindful of XAML injection attacks. XAML is a markup language that directly represents object
# instantiation and execution. That means elements created in XAML can interact with system resources (for example, network access and file
# system IO).
dotnet_diagnostic.CA3010.severity = warning

# CA3011: Review code for DLL injection vulnerabilities
# When working with untrusted input, be mindful of loading untrusted code. If your web application loads untrusted code, an attacker may be
# able to inject malicious DLLs into your process and execute malicious code.
dotnet_diagnostic.CA3011.severity = warning

# CA3012: Review code for regex injection vulnerabilities
# When working with untrusted input, be mindful of regex injection attacks. An attacker can use regex injection to maliciously modify a regular
# expression, to make the regex match unintended results, or to make the regex consume excessive CPU resulting in a Denial of Service attack.
dotnet_diagnostic.CA3012.severity = warning

# CA3061: Do not add schema by URL
# Do not use the unsafe overload of the Add method because it may cause dangerous external references.
dotnet_diagnostic.CA3061.severity = warning

# CA3075: Insecure DTD Processing
# If you use insecure DTDProcessing instances or reference external entity sources, the parser may accept untrusted input and disclose
# sensitive information to attackers.
dotnet_diagnostic.CA3075.severity = warning

# CA3076: Insecure XSLT Script Execution
# If you execute Extensible Stylesheet Language Transformations (XSLT) in .NET applications insecurely, the processor may resolve untrusted
# URI references that could disclose sensitive information to attackers, leading to Denial of Service and Cross-Site attacks.
dotnet_diagnostic.CA3076.severity = warning

# CA3077: Insecure Processing in API Design, XML Document and XML Text Reader
# When designing an API derived from XMLDocument and XMLTextReader, be mindful of DtdProcessing. Using insecure DTDProcessing instances when
# referencing or resolving external entity sources or setting insecure values in the XML may lead to information disclosure.
dotnet_diagnostic.CA3077.severity = warning

# CA3147: Mark verb handlers with ValidateAntiForgeryToken
# When designing an ASP.NET MVC controller, be mindful of cross-site request forgery attacks. A cross-site request forgery attack can send
# malicious requests from an authenticated user to your ASP.NET MVC controller.
dotnet_diagnostic.CA3147.severity = warning

# CA5122: P/Invoke declarations should not be safe critical
# Methods are marked as SecuritySafeCritical when they perform a security sensitive operation, but are also safe to be used by transparent
# code. Transparent code may never directly call native code through a P/Invoke. Therefore, marking a P/Invoke as security safe critical will
# not enable transparent code to call it, and is misleading for security analysis.
dotnet_diagnostic.CA5122.severity = warning


# CA5350: Do Not Use Weak Cryptographic Algorithms
# Weak encryption algorithms and hashing functions are used today for a number of reasons, but they should not be used to guarantee the
# confidentiality or integrity of the data they protect. This rule triggers when it finds TripleDES, SHA1, or RIPEMD160 algorithms in the code.
dotnet_diagnostic.CA5350.severity = warning

# CA5351: Do Not Use Broken Cryptographic Algorithms
# Broken cryptographic algorithms are not considered secure and their use should be strongly discouraged. This rule triggers when it finds the
# MD5 hash algorithm or either the DES or RC2 encryption algorithms in code.
dotnet_diagnostic.CA5351.severity = warning

# CA5359: Do not disable certificate validation
# A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent
# to the intended server. If the ServerCertificateValidationCallback always returns true, any certificate will pass validation.
dotnet_diagnostic.CA5359.severity = warning

# CA5360: Do not call dangerous methods in deserialization
# Insecure deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a
# Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It's frequently possible for malicious users to
# abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke
# dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks
# such as DoS attacks, authentication bypasses, and remote code execution.
dotnet_diagnostic.CA5360.severity = warning

# CA5361: Do not disable SChannel use of strong crypto
# Setting Switch.System.Net.DontEnableSchUseStrongCrypto to true weakens the cryptography used in outgoing Transport Layer Security (TLS)
# connections. Weaker cryptography can compromise the confidentiality of communication between your application and the server, making it easier
# for attackers to eavesdrop sensitive data.
dotnet_diagnostic.CA5361.severity = warning

# CA5362: Potential reference cycle in deserialized object graph
# If deserializing untrusted data, then any code processing the deserialized object graph needs to handle reference cycles without going into
# infinite loops. This includes both code that's part of a deserialization callback and code that processes the object graph after
# deserialization completed. Otherwise, an attacker could perform a Denial-of-Service attack with malicious data containing a reference cycle.
dotnet_diagnostic.CA5362.severity = warning

# CA5363: Do not disable request validation
# Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content that
# can lead to injection attacks, including cross-site-scripting.
dotnet_diagnostic.CA5363.severity = warning

# CA5364: Do not use deprecated security protocols
# Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS). Older
# protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities. Avoid older protocol
# versions to minimize risk.
dotnet_diagnostic.CA5364.severity = warning

# CA5365: Do Not Disable HTTP Header Checking
# HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This
# encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.
dotnet_diagnostic.CA5365.severity = warning

# CA5366: Use XmlReader For DataSet Read XML
# Using a DataSet to read XML with untrusted data may load dangerous external references, which should be restricted by using an XmlReader
# with a secure resolver or with DTD processing disabled.
dotnet_diagnostic.CA5366.severity = warning

# CA5367: Do Not Serialize Types With Pointer Fields
# This rule checks whether there's a serializable class with a pointer field or property. Members that can't be serialized can be a pointer,
# such as static members or fields marked with NonSerializedAttribute.
dotnet_diagnostic.CA5367.severity = warning

# CA5368: Set ViewStateUserKey For Classes Derived From Page
# Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the
# view-state variable for individual users so that attackers cannot use the variable to generate an attack. Otherwise, there will be
# vulnerabilities to cross-site request forgery.
dotnet_diagnostic.CA5368.severity = warning

# CA5369: Use XmlReader for Deserialize
# Processing untrusted DTD and XML schemas may enable loading dangerous external references, which should be restricted by using an XmlReader
# with a secure resolver or with DTD and XML inline schema processing disabled.
dotnet_diagnostic.CA5369.severity = warning

# CA5370: Use XmlReader for validating reader
# Processing untrusted DTD and XML schemas may enable loading dangerous external references. This dangerous loading can be restricted by using
# an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.
dotnet_diagnostic.CA5370.severity = warning

# CA5371: Use XmlReader for schema read
# Processing untrusted DTD and XML schemas may enable loading dangerous external references. Using an XmlReader with a secure resolver or with
# DTD and XML inline schema processing disabled restricts this.
dotnet_diagnostic.CA5371.severity = warning

# CA5372: Use XmlReader for XPathDocument
# Processing XML from untrusted data may load dangerous external references, which can be restricted by using an XmlReader with a secure
# resolver or with DTD processing disabled.
dotnet_diagnostic.CA5372.severity = warning

# CA5373: Do not use obsolete key derivation function
# This rule detects the invocation of weak key derivation methods System.Security.Cryptography.PasswordDeriveBytes and
# Rfc2898DeriveBytes.CryptDeriveKey. System.Security.Cryptography.PasswordDeriveBytes used a weak algorithm PBKDF1.
dotnet_diagnostic.CA5373.severity = warning

# CA5374: Do Not Use XslTransform
# This rule checks if System.Xml.Xsl.XslTransform is instantiated in the code. System.Xml.Xsl.XslTransform is now obsolete and shouldn't be used.
dotnet_diagnostic.CA5374.severity = warning

# CA5375: Do not use account shared access signature
# An account SAS can delegate access to read, write, and delete operations on blob containers, tables, queues, and file shares that are not
# permitted with a service SAS. However, it doesn't support container-level policies and has less flexibility and control over the permissions
# that are granted. Once malicious users get it, your storage account will be compromised easily.
dotnet_diagnostic.CA5375.severity = warning

# CA5376: Use SharedAccessProtocol HttpsOnly
# SAS is sensitive data that can't be transported in plain text on HTTP.
dotnet_diagnostic.CA5376.severity = warning

# CA5377: Use container level access policy
# A container-level access policy can be modified or revoked at any time. It provides greater flexibility and control over the permissions
# that are granted.
dotnet_diagnostic.CA5377.severity = warning

# CA5378: Do not disable ServicePointManagerSecurityProtocols
# Setting Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols to true limits Windows Communication Framework's (WCF)
# Transport Layer Security (TLS) connections to using TLS 1.0. That version of TLS will be deprecated.
dotnet_diagnostic.CA5378.severity = warning

# CA5379: Do not use weak key derivation function algorithm
# The Rfc2898DeriveBytes class defaults to using the SHA1 algorithm. You should specify the hash algorithm to use in some overloads of the
# constructor with SHA256 or higher. Note, HashAlgorithm property only has a get accessor and doesn't have a overriden modifier.
dotnet_diagnostic.CA5379.severity = warning

# CA5380: Do not add certificates to root store
# This rule detects code that adds a certificate into the Trusted Root Certification Authorities certificate store. By default, the Trusted
# Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root
# Certificate Program.
dotnet_diagnostic.CA5380.severity = warning

# CA5381: Ensure certificates are not added to root store
# This rule detects code that potentially adds a certificate into the Trusted Root Certification Authorities certificate store. By default,
# the Trusted Root Certification Authorities certificate store is configured with a set of public certification authorities (CAs) that has met
# the requirements of the Microsoft Root Certificate Program.
dotnet_diagnostic.CA5381.severity = warning

# CA5382: Use secure cookies in ASP.NET Core
# Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using
# Transport Layer Security (TLS).
dotnet_diagnostic.CA5382.severity = warning

# CA5383: Ensure use secure cookies in ASP.NET Core
# Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using
# Transport Layer Security (TLS).
dotnet_diagnostic.CA5383.severity = warning

# CA5384: Do not use digital signature algorithm (DSA)
# DSA is a weak asymmetric encryption algorithm.
dotnet_diagnostic.CA5384.severity = warning

# CA5385: Use Rivest-Shamir-Adleman (RSA) algorithm with sufficient key size
# An RSA key smaller than 2048 bits is more vulnerable to brute force attacks.
dotnet_diagnostic.CA5385.severity = warning

# CA5386: Avoid hardcoding SecurityProtocolType value
# Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).
# Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current. In the future, TLS 1.2 and TLS 1.3 may be
# deprecated. To ensure that your application remains secure, avoid hardcoding a protocol version and target at least .NET Framework v4.7.1.
dotnet_diagnostic.CA5386.severity = warning

# CA5387: Do not use weak key derivation function with insufficient iteration count
# This rule checks if a cryptographic key was generated by Rfc2898DeriveBytes with an iteration count of less than 100,000. A higher iteration
# count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.
dotnet_diagnostic.CA5387.severity = warning

# CA5388: Ensure sufficient iteration count when using weak key derivation function
# This rule checks if a cryptographic key was generated by Rfc2898DeriveBytes with an iteration count that may be less than 100,000. A higher
# iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.
dotnet_diagnostic.CA5388.severity = warning

# CA5389: Do not add archive item's path to the target file system path
# File path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config
# changes and remote code execution via lay-and-wait technique.
dotnet_diagnostic.CA5389.severity = warning

# CA5390: Do not hard-code encryption key
# For a symmetric algorithm to be successful, the secret key must be known only to the sender and the receiver. When a key is hard-coded, it is
# easily discovered. Even with compiled binaries, it is easy for malicious users to extract it. Once the private key is compromised, the cipher
# text can be decrypted directly and is not protected anymore.
dotnet_diagnostic.CA5390.severity = warning

# CA5391: Use antiforgery tokens in ASP.NET Core MVC controllers
# Handling a POST, PUT, PATCH, or DELETE request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks.
# A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.
dotnet_diagnostic.CA5391.severity = warning

# CA5392: Use DefaultDllImportSearchPaths attribute for P/Invokes
# By default, P/Invoke functions using DllImportAttribute probe a number of directories, including the current working directory for the library
# to load. This can be a security issue for certain applications, leading to DLL hijacking.
dotnet_diagnostic.CA5392.severity = warning

# CA5393: Do not use unsafe DllImportSearchPath value
# There could be a malicious DLL in the default DLL search directories and assembly directories. Or, depending on where your application is run
# from, there could be a malicious DLL in the application's directory.
dotnet_diagnostic.CA5393.severity = warning

# CA5394: Do not use insecure randomness
# Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated.
dotnet_diagnostic.CA5394.severity = warning

# CA5395: Miss HttpVerb attribute for action methods
# All the action methods that create, edit, delete, or otherwise modify data needs to be protected with the antiforgery attribute from cross-site
# request forgery attacks. Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.
dotnet_diagnostic.CA5395.severity = warning

# CA5396: Set HttpOnly to true for HttpCookie
# As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow
# scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies.
dotnet_diagnostic.CA5396.severity = warning

# CA5397: Do not use deprecated SslProtocols values
# Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS). Older
# protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities. Avoid older protocol versions
# to minimize risk.
dotnet_diagnostic.CA5397.severity = warning

# CA5398: Avoid hardcoded SslProtocols values
# Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS). Protocol
# versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current. In the future, TLS 1.2 and TLS 1.3 may be deprecated. To
# ensure that your application remains secure, avoid hardcoding a protocol version.
dotnet_diagnostic.CA5398.severity = warning

# CA5399: Definitely disable HttpClient certificate revocation list check
# A revoked certificate isn't trusted anymore. It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS
# communication.
dotnet_diagnostic.CA5399.severity = warning

# CA5400: Ensure HttpClient certificate revocation list check is not disabled
# A revoked certificate isn't trusted anymore. It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS
# communication.
dotnet_diagnostic.CA5400.severity = warning

# CA5401: Do not use CreateEncryptor with non-default IV
# Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.
dotnet_diagnostic.CA5401.severity = warning

# CA5402: Use CreateEncryptor with the default IV
# Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.
dotnet_diagnostic.CA5402.severity = warning

# Default severity for analyzer diagnostics with category 'StyleCop.CSharp.OrderingRules'
dotnet_analyzer_diagnostic.category-StyleCop.CSharp.OrderingRules.severity = silent


# StyleCop rules

# SA0001: XmlCommentAnalysisDisabled
# All diagnostics of XML documentation comments has been disabled due to the current project configuration.
dotnet_diagnostic.SA0001.severity = warning

# SA0002: InvalidSettingsFile
# The stylecop.json settings file could not be loaded due to a deserialization error.
dotnet_diagnostic.SA0002.severity = warning

# SA1000: KeywordsMustBeSpacedCorrectly
# The spacing around a C# keyword is incorrect.
dotnet_diagnostic.SA1000.severity = warning


# SA1001: CommasMustBeSpacedCorrectly
# The spacing around a comma is incorrect, within a C# code file.
dotnet_diagnostic.SA1001.severity = warning

# SA1002: SemicolonsMustBeSpacedCorrectly
# The spacing around a semicolon is incorrect, within a C# code file.
dotnet_diagnostic.SA1002.severity = warning

# SA1003: SymbolsMustBeSpacedCorrectly
# The spacing around an operator symbol is incorrect, within a C# code file.
# Disable reason: We allow colons at the end of line, for example with calling base constructors.
dotnet_diagnostic.SA1003.severity = none

# SA1004: DocumentationLinesMustBeginWithSingleSpace
# A line within a documentation header above a C# element does not begin with a single space.
dotnet_diagnostic.SA1004.severity = warning

# SA1005: SingleLineCommentsMustBeginWithSingleSpace
# A single-line comment within a C# code file does not begin with a single space.
dotnet_diagnostic.SA1005.severity = warning

# SA1006: PreprocessorKeywordsMustNotBePrecededBySpace
# A C# preprocessor-type keyword is preceded by space.
dotnet_diagnostic.SA1006.severity = warning

# SA1007: OperatorKeywordMustBeFollowedBySpace
# The operator keyword within a C# operator overload method is not followed by any whitespace.
dotnet_diagnostic.SA1007.severity = warning

# SA1008: OpeningParenthesisMustBeSpacedCorrectly
# An opening parenthesis within a C# statement is not spaced correctly.
dotnet_diagnostic.SA1008.severity = warning

# SA1009: ClosingParenthesisMustBeSpacedCorrectly
# A closing parenthesis within a C# statement is not spaced correctly.
# Disable reason: We allow colons after closing parenthesis.
dotnet_diagnostic.SA1009.severity = none

# SA1010: OpeningSquareBracketsMustBeSpacedCorrectly
# An opening square bracket within a C# statement is not spaced correctly.
dotnet_diagnostic.SA1010.severity = warning

# SA1011: ClosingSquareBracketsMustBeSpacedCorrectly
# A closing square bracket within a C# statement is not spaced correctly.
# Disable reason: This rule does not work with modern nullability syntax.
dotnet_diagnostic.SA1011.severity = none

# SA1012: OpeningBracesMustBeSpacedCorrectly
# An opening brace within a C# element is not spaced correctly.
dotnet_diagnostic.SA1012.severity = warning

# SA1013: ClosingBracesMustBeSpacedCorrectly
# A closing brace within a C# element is not spaced correctly.
dotnet_diagnostic.SA1013.severity = warning

# SA1014: OpeningGenericBracketsMustBeSpacedCorrectly
# An opening generic bracket within a C# element is not spaced correctly.
dotnet_diagnostic.SA1014.severity = warning

# SA1015: ClosingGenericBracketsMustBeSpacedCorrectly
# A closing generic bracket within a C# element is not spaced correctly.
dotnet_diagnostic.SA1015.severity = warning

# SA1016: OpeningAttributeBracketsMustBeSpacedCorrectly
# An opening attribute bracket within a C# element is not spaced correctly.
dotnet_diagnostic.SA1016.severity = warning

# SA1017: ClosingAttributeBracketsMustBeSpacedCorrectly
# A closing attribute bracket within a C# element is not spaced correctly.
dotnet_diagnostic.SA1017.severity = warning

# SA1018: NullableTypeSymbolsMustNotBePrecededBySpace
# A nullable type symbol within a C# element is not spaced correctly.
dotnet_diagnostic.SA1018.severity = warning

# SA1019: MemberAccessSymbolsMustBeSpacedCorrectly
# The spacing around a member access symbol is incorrect, within a C# code file.
dotnet_diagnostic.SA1019.severity = warning

# SA1020: IncrementDecrementSymbolsMustBeSpacedCorrectly
# An increment or decrement symbol within a C# element is not spaced correctly.
dotnet_diagnostic.SA1020.severity = warning

# SA1021: NegativeSignsMustBeSpacedCorrectly
# A negative sign within a C# element is not spaced correctly.
dotnet_diagnostic.SA1021.severity = warning

# SA1022: PositiveSignsMustBeSpacedCorrectly
# A positive sign within a C# element is not spaced correctly.
dotnet_diagnostic.SA1022.severity = warning

# SA1023: DereferenceAndAccessOfMustBeSpacedCorrectly
# A dereference symbol or an access-of symbol within a C# element is not spaced correctly.
dotnet_diagnostic.SA1023.severity = warning

# SA1024: ColonsMustBeSpacedCorrectly
# A colon within a C# element is not spaced correctly.
# Disable reason: We use colons without space in front of them.
dotnet_diagnostic.SA1024.severity = none

# SA1025: CodeMustNotContainMultipleWhitespaceInARow
# The code contains multiple whitespace characters in a row.
dotnet_diagnostic.SA1025.severity = warning

# SA1026: CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation
# An implicitly typed new array allocation within a C# code file is not spaced correctly.
dotnet_diagnostic.SA1026.severity = warning

# SA1027: UseTabsCorrectly
# The code contains a tab or space character which is not consistent with the current project settings.
dotnet_diagnostic.SA1027.severity = warning

# SA1028: CodeMustNotContainTrailingWhitespace
# A line of code ends with a space, tab, or other whitespace characters before the end of line character(s).
dotnet_diagnostic.SA1028.severity = warning


# SA1100: DoNotPrefixCallsWithBaseUnlessLocalImplementationExists
# A call to a member from an inherited class begins with base., and the local class does not contain an override or implementation of the member.
dotnet_diagnostic.SA1100.severity = warning

# SA1101: PrefixLocalCallsWithThis
# A call to an instance member of the local class or a base class is not prefixed with 'this.', within a C# code file.
dotnet_diagnostic.SA1101.severity = warning

# SA1102: QueryClauses
# A C# query clause does not begin on the same line as the previous clause, or on the next line.
dotnet_diagnostic.SA1102.severity = warning

# SA1103: QueryClauses
# The clauses within a C# query expression are not all placed on the same line, and each clause is not placed on its own line.
dotnet_diagnostic.SA1103.severity = warning

# SA1104: QueryClauses
# A clause within a C# query expression begins on the same line as the previous clause, when the previous clause spans across multiple lines.
dotnet_diagnostic.SA1104.severity = warning

# SA1105: QueryClauses
# A clause within a C# query expression spans across multiple lines, and does not begin on its own line.
dotnet_diagnostic.SA1105.severity = warning

# SA1106: CodeMustNotContainEmptyStatements
# The C# code contains an extra semicolon.
dotnet_diagnostic.SA1106.severity = warning

# SA1107: CodeMustNotContainMultipleStatementsOnOneLine
# The C# code contains more than one statement on a single line.
dotnet_diagnostic.SA1107.severity = warning

# SA1108: BlockStatementsMustNotContainEmbeddedComments
# A C# statement contains a comment between the declaration of the statement and the opening brace of the statement.
dotnet_diagnostic.SA1108.severity = warning

# SA1109: BlockStatementsMustNotContainEmbeddedRegions
# A C# statement contains a region tag between the declaration of the statement and the opening brace of the statement.
dotnet_diagnostic.SA1109.severity = warning

# SA1110: OpeningParenthesisMustBeOnDeclarationLine
# The opening parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the method or indexer name.
# Disable reason: Sometimes we want open brackets on their own lines.
dotnet_diagnostic.SA1110.severity = none

# SA1111: ClosingParenthesisMustBeOnLineOfLastParameter
# The closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the last parameter.
# Disable reason: Sometimes we want open brackets on their own lines.
dotnet_diagnostic.SA1111.severity = none

# SA1112: ClosingParenthesisMustBeOnLineOfOpeningParenthesis
# The closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the opening bracket when the element does not take any parameters.
dotnet_diagnostic.SA1112.severity = warning

# SA1113: CommaMustBeOnSameLineAsPreviousParameter
# A comma between two parameters in a call to a C# method or indexer, or in the declaration of a method or indexer, is not placed on the same line as the previous parameter.
dotnet_diagnostic.SA1113.severity = warning

# SA1114: ParameterListMustFollowDeclaration
# The start of the parameter list for a method or indexer call or declaration does not begin on the same line as the opening bracket, or on the line after the opening bracket.
dotnet_diagnostic.SA1114.severity = warning

# SA1115: ParameterMustFollowComma
# A parameter within a C# method or indexer call or declaration does not begin on the same line as the previous parameter, or on the next line.
dotnet_diagnostic.SA1115.severity = warning

# SA1116: SplitParametersMustStartOnLineAfterDeclaration
# The parameters to a C# method or indexer call or declaration span across multiple lines, but the first parameter does not start on the line after the opening bracket.
# Disable reason: We put parameters on the same line as opening bracket.
dotnet_diagnostic.SA1116.severity = none

# SA1117: ParametersMustBeOnSameLineOrSeparateLines
# The parameters to a C# method or indexer call or declaration are not all on the same line or each on a separate line.
# Disable reason: We use multiple line for methods with many arguments but prefer more than one argument on each line.
dotnet_diagnostic.SA1117.severity = none

# SA1118: ParameterMustNotSpanMultipleLines
# A parameter to a C# method or indexer, other than the first parameter, spans across multiple lines.
dotnet_diagnostic.SA1118.severity = warning

# SA1119: StatementMustNotUseUnnecessaryParenthesis
# A C# statement contains parenthesis which are unnecessary and should be removed.
dotnet_diagnostic.SA1119.severity = warning

# SA1120: CommentsMustContainText
# The C# comment does not contain any comment text.
dotnet_diagnostic.SA1120.severity = warning

# SA1121: UseBuiltInTypeAlias
# The code uses one of the basic C# types, but does not use the built-in alias for the type.
dotnet_diagnostic.SA1121.severity = warning

# SA1122: UseStringEmptyForEmptyStrings
# The C# code includes an empty string, written as "".
dotnet_diagnostic.SA1122.severity = warning

# SA1123: DoNotPlaceRegionsWithinElements
# The C# code contains a region within the body of a code element.
dotnet_diagnostic.SA1123.severity = warning

# SA1124: DoNotUseRegions
# The C# code contains a region.
dotnet_diagnostic.SA1124.severity = warning

# SA1125: UseShorthandForNullableTypes
# The Nullable type has been defined not using the C# shorthand.
dotnet_diagnostic.SA1125.severity = warning

# SA1126: PrefixCallsCorrectly
# A call to a member is not prefixed with the 'this.', 'base.', 'object.' or 'typename.' prefix to indicate the intended method call, within a C# code file.
dotnet_diagnostic.SA1126.severity = warning

# SA1127: GenericTypeConstraintsMustBeOnOwnLine
# A generic constraint on a type or method declaration is on the same line as the declaration, within a C# code file.
dotnet_diagnostic.SA1127.severity = warning

# SA1128: ConstructorInitializerMustBeOnOwnLine
# A constructor initializer is on the same line as the constructor declaration, within a C# code file.
# Disable reason: We use colon on the first line of constructor which confuses this rule's analyzer.
dotnet_diagnostic.SA1128.severity = none

# SA1129: DoNotUseDefaultValueTypeConstructor
# A value type was constructed using the syntax new T().
dotnet_diagnostic.SA1129.severity = warning

# SA1130: UseLambdaSyntax
# An anonymous method was declared using the form delegate (parameters) { }, when a lambda expression would provide equivalent behavior with the syntax (parameters) => { }.
dotnet_diagnostic.SA1130.severity = warning

# SA1131: UseReadableConditions
# A comparison was made between a variable and a literal or constant value, and the variable appeared on the right-hand side of the expression.
# Disable reason: When checking value within a range, `(loBound <= value) && (value <= hiBound)` is more readable.
dotnet_diagnostic.SA1131.severity = none

# SA1132: DoNotCombineFields
# Two or more fields were declared in the same field declaration syntax.
dotnet_diagnostic.SA1132.severity = warning

# SA1133: DoNotCombineAttributes
# Two or more attributes appeared within the same set of square brackets.
dotnet_diagnostic.SA1133.severity = warning

# SA1134: AttributesMustNotShareLine
# An attribute is placed on the same line of code as another attribute or element.
dotnet_diagnostic.SA1134.severity = warning

# SA1135: UsingDirectivesMustBeQualified
# A using directive is not qualified.
dotnet_diagnostic.SA1135.severity = warning

# SA1136: EnumValuesShouldBeOnSeparateLines
# Multiple enum values are placed on the same line of code.
dotnet_diagnostic.SA1136.severity = warning

# SA1137: ElementsShouldHaveTheSameIndentation
# Two sibling elements which each start on their own line have different levels of indentation.
dotnet_diagnostic.SA1137.severity = warning

# SA1139: UseLiteralsSuffixNotationInsteadOfCasting
# Use literal suffix notation instead of casting.
dotnet_diagnostic.SA1139.severity = warning

# SA1141: UseTupleSyntax
# Use tuple syntax instead of the underlying ValueTuple implementation type.
dotnet_diagnostic.SA1141.severity = warning

# SA1142: ReferToTupleElementsByName
# An element of a tuple was referenced by its metadata name when an element name is available.
dotnet_diagnostic.SA1142.severity = warning

# SA1200: UsingDirectivesMustBePlacedCorrectly
# A C# using directive is placed outside of a namespace element.
# Disable reason: We use usings outside namespace elements.
dotnet_diagnostic.SA1200.severity = none

# SA1201: ElementsMustAppearInTheCorrectOrder
# An element within a C# code file is out of order in relation to the other elements in the code.
# Disable reason: We do write constructors after properties.
dotnet_diagnostic.SA1201.severity = none

# SA1202: ElementsMustBeOrderedByAccess
# An element within a C# code file is out of order within regard to access level, in relation to other elements in the code.
# Disable reason: We use private members before public.
dotnet_diagnostic.SA1202.severity = none

# SA1203: ConstantsMustAppearBeforeFields
# A constant field is placed beneath a non-constant field.
dotnet_diagnostic.SA1203.severity = warning

# SA1204: StaticElementsMustAppearBeforeInstanceElements
# A static element is positioned beneath an instance element of the same type.
dotnet_diagnostic.SA1204.severity = warning

# SA1205: PartialElementsMustDeclareAccess
# The partial element does not have an access modifier defined.
dotnet_diagnostic.SA1205.severity = warning

# SA1206: DeclarationKeywordsMustFollowOrder
# The keywords within the declaration of an element do not follow a standard ordering scheme.
# Disable reason: IDE0036 (i.e. `csharp_preferred_modifier_order`) specifies an absolute order of modifiers whereas SA1206 specifies an order of modifier categories. See https://github.com/DotNetAnalyzers/StyleCopAnalyzers/issues/3587.
dotnet_diagnostic.SA1206.severity = none

# SA1207: ProtectedMustComeBeforeInternal
# The keyword protected is positioned after the keyword internal within the declaration of a protected internal C# element.
dotnet_diagnostic.SA1207.severity = warning

# SA1208: SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives
# A using directive which declares a member of the System namespace appears after a using directive which declares a member of a different namespace, within a C# code file.
dotnet_diagnostic.SA1208.severity = warning

# SA1209: UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives
# A using-alias directive is positioned before a regular using directive.
dotnet_diagnostic.SA1209.severity = warning

# SA1210: UsingDirectivesMustBeOrderedAlphabeticallyByNamespace
# The using directives within a C# code file are not sorted alphabetically by namespace.
dotnet_diagnostic.SA1210.severity = warning

# SA1211: UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName
# The using-alias directives within a C# code file are not sorted alphabetically by alias name.
dotnet_diagnostic.SA1211.severity = warning

# SA1212: PropertyAccessorsMustFollowOrder
# A get accessor appears after a set accessor within a property or indexer.
dotnet_diagnostic.SA1212.severity = warning

# SA1213: EventAccessorsMustFollowOrder
# An add accessor appears after a remove accessor within an event.
dotnet_diagnostic.SA1213.severity = warning

# SA1214: ReadonlyElementsMustAppearBeforeNonReadonlyElements
# A readonly field is positioned beneath a non-readonly field.
dotnet_diagnostic.SA1214.severity = warning

# SA1215: InstanceReadonlyElementsMustAppearBeforeInstanceNonReadonlyElements
# An instance readonly element is positioned beneath an instance non-readonly element of the same type.
dotnet_diagnostic.SA1215.severity = warning

# SA1216: UsingStaticDirectivesMustBePlacedAtTheCorrectLocation
# A using static directive is positioned at the wrong location (before a regular using directive or after an alias using directive).
dotnet_diagnostic.SA1216.severity = warning

# SA1217: UsingStaticDirectivesMustBeOrderedAlphabetically
# The using static directives within a C# code file are not sorted alphabetically by full type name.
dotnet_diagnostic.SA1217.severity = warning


# SA1300: ElementMustBeginWithUpperCaseLetter
# The name of a C# element does not begin with an upper-case letter.
# Disable reason: We use lower case letters for private, protected, and internal elements.
dotnet_diagnostic.SA1300.severity = none

# SA1301: ElementMustBeginWithLowerCaseLetter
# There are currently no situations in which this rule will fire.
dotnet_diagnostic.SA1301.severity = warning

# SA1302: InterfaceNamesMustBeginWithI
# The name of a C# interface does not begin with the capital letter I.
dotnet_diagnostic.SA1302.severity = warning

# SA1303: ConstFieldNamesMustBeginWithUpperCaseLetter
# The name of a constant C# field should begin with an upper-case letter.
dotnet_diagnostic.SA1303.severity = warning

# SA1304: NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter
# The name of a non-private readonly C# field should being with an upper-case letter.
# Disable reason: We use lower case letters for private, protected, and internal elements.
dotnet_diagnostic.SA1304.severity = none

# SA1305: FieldNamesMustNotUseHungarianNotation
# The name of a field or variable in C# uses Hungarian notation.
# Disable reason: Parser of this rule is often confused.
dotnet_diagnostic.SA1305.severity = none

# SA1306: FieldNamesMustBeginWithLowerCaseLetter
# The name of a field in C# does not begin with a lower-case letter.
dotnet_diagnostic.SA1306.severity = warning

# SA1307: AccessibleFieldsMustBeginWithUpperCaseLetter
# The name of a public or internal field in C# does not begin with an upper-case letter.
# Disable reason: We use lower case letters for private, protected, and internal elements.
dotnet_diagnostic.SA1307.severity = none

# SA1308: VariableNamesMustNotBePrefixed
# A field name in C# is prefixed with m_ or s_.
dotnet_diagnostic.SA1308.severity = warning

# SA1309: FieldNamesMustNotBeginWithUnderscore
# A field name in C# begins with an underscore.
dotnet_diagnostic.SA1309.severity = warning

# SA1310: FieldNamesMustNotContainUnderscore
# A field name in C# contains an underscore.
dotnet_diagnostic.SA1310.severity = warning

# SA1311: StaticReadonlyFieldsMustBeginWithUpperCaseLetter
# The name of a static readonly field does not begin with an upper-case letter.
# Disable reason: We use lower case letters for private, protected, and internal elements.
dotnet_diagnostic.SA1311.severity = none

# SA1312: VariableNamesMustBeginWithLowerCaseLetter
# The name of a variable in C# does not begin with a lower-case letter.
dotnet_diagnostic.SA1312.severity = warning

# SA1313: ParameterNamesMustBeginWithLowerCaseLetter
# The name of a parameter in C# does not begin with a lower-case letter.
dotnet_diagnostic.SA1313.severity = warning

# SA1314: TypeParameterNamesMustBeginWithT
# The name of a C# type parameter does not begin with the capital letter T.
dotnet_diagnostic.SA1314.severity = warning

# SA1316: TupleElementNamesShouldUseCorrectCasing
# Element names within a tuple type should have the correct casing.
dotnet_diagnostic.SA1316.severity = warning


# SA1400: AccessModifierMustBeDeclared
# The access modifier for a C# element has not been explicitly defined.
dotnet_diagnostic.SA1400.severity = warning

# SA1401: FieldsMustBePrivate
# A field within a C# class has an access modifier other than private.
dotnet_diagnostic.SA1401.severity = warning

# SA1402: FileMayOnlyContainASingleType
# A C# code file contains more than one unique type.
# Disable reason: Sometimes we put small classes to the same file where it makes good sense.
dotnet_diagnostic.SA1402.severity = none

# SA1403: FileMayOnlyContainASingleNamespace
# A C# code file contains more than one namespace.
dotnet_diagnostic.SA1403.severity = warning

# SA1404: CodeAnalysisSuppressionMustHaveJustification
# A Code Analysis SuppressMessage attribute does not include a justification.
dotnet_diagnostic.SA1404.severity = warning

# SA1405: DebugAssertMustProvideMessageText
# A call to Debug.Assert in C# code does not include a descriptive message.
dotnet_diagnostic.SA1405.severity = warning

# SA1406: DebugFailMustProvideMessageText
# A call to Debug.Fail in C# code does not include a descriptive message.
dotnet_diagnostic.SA1406.severity = warning

# SA1407: ArithmeticExpressionsMustDeclarePrecedence
# A C# statement contains a complex arithmetic expression which omits parenthesis around operators.
dotnet_diagnostic.SA1407.severity = warning

# SA1408: ConditionalExpressionsMustDeclarePrecedence
# A C# statement contains a complex conditional expression which omits parenthesis around operators.
dotnet_diagnostic.SA1408.severity = warning

# SA1409: RemoveUnnecessaryCode
# A C# file contains code which is unnecessary and can be removed without changing the overall logic of the code.
dotnet_diagnostic.SA1409.severity = warning

# SA1410: RemoveDelegateParenthesisWhenPossible
# A call to a C# anonymous method does not contain any method parameters, yet the statement still includes parenthesis.
dotnet_diagnostic.SA1410.severity = warning

# SA1411: AttributeConstructorMustNotUseUnnecessaryParenthesis
# An attribute declaration does not contain any parameters, yet it still includes parenthesis.
dotnet_diagnostic.SA1411.severity = warning

# SA1412: StoreFilesAsUtf8
# The encoding of the file is not UTF-8 with byte order mark.
# Disable reason: We allow UTF-8 files without BOM.
dotnet_diagnostic.SA1412.severity = none

# SA1413: UseTrailingCommasInMultiLineInitializers
# A multi-line initializer should use a comma on the last item.
dotnet_diagnostic.SA1413.severity = warning

# SA1414: TupleTypesInSignaturesShouldHaveElementNames
# Tuple types appearing in member declarations should have explicitly named tuple elements.
dotnet_diagnostic.SA1414.severity = warning


# SA1500: BracesForMultiLineStatementsMustNotShareLine
# The opening or closing brace within a C# statement, element, or expression is not placed on its own line.
dotnet_diagnostic.SA1500.severity = warning

# SA1501: StatementMustNotBeOnSingleLine
# A C# statement containing opening and closing braces is written completely on a single line.
dotnet_diagnostic.SA1501.severity = warning

# SA1502: ElementMustNotBeOnSingleLine
# A C# element containing opening and closing braces is written completely on a single line.
dotnet_diagnostic.SA1502.severity = warning

# SA1503: BracesMustNotBeOmitted
# The opening and closing braces for a C# statement have been omitted.
# Disable reason: We allow single lines without braces.
dotnet_diagnostic.SA1503.severity = none

# SA1504: AllAccessorsMustBeSingleLineOrMultiLine
# Within a C# property, indexer or event, at least one of the child accessors is written on a single line, and at least one of the child accessors is written across multiple lines.
dotnet_diagnostic.SA1504.severity = warning

# SA1505: OpeningBracesMustNotBeFollowedByBlankLine
# An opening brace within a C# element, statement, or expression is followed by a blank line.
dotnet_diagnostic.SA1505.severity = warning

# SA1506: ElementDocumentationHeadersMustNotBeFollowedByBlankLine
# An element documentation header above a C# element is followed by a blank line.
dotnet_diagnostic.SA1506.severity = warning

# SA1507: CodeMustNotContainMultipleBlankLinesInARow
# The C# code contains multiple blank lines in a row.
dotnet_diagnostic.SA1507.severity = warning

# SA1508: ClosingBracesMustNotBePrecededByBlankLine
# A closing brace within a C# element, statement, or expression is preceded by a blank line.
dotnet_diagnostic.SA1508.severity = warning

# SA1509: OpeningBracesMustNotBePrecededByBlankLine
# An opening brace within a C# element, statement, or expression is preceded by a blank line.
dotnet_diagnostic.SA1509.severity = warning

# SA1510: ChainedStatementBlocksMustNotBePrecededByBlankLine
# Chained C# statements are separated by a blank line.
dotnet_diagnostic.SA1510.severity = warning

# SA1511: WhileDoFooterMustNotBePrecededByBlankLine
# The while footer at the bottom of a do-while statement is separated from the statement by a blank line.
dotnet_diagnostic.SA1511.severity = warning

# SA1512: SingleLineCommentsMustNotBeFollowedByBlankLine
# A single-line comment within C# code is followed by a blank line.
dotnet_diagnostic.SA1512.severity = warning

# SA1513: ClosingBraceMustBeFollowedByBlankLine
# A closing brace within a C# element, statement, or expression is not followed by a blank line.
dotnet_diagnostic.SA1513.severity = warning

# SA1514: ElementDocumentationHeaderMustBePrecededByBlankLine
# An element documentation header above a C# element is not preceded by a blank line.
dotnet_diagnostic.SA1514.severity = warning

# SA1515: SingleLineCommentMustBePrecededByBlankLine
# A single-line comment within C# code is not preceded by a blank line.
dotnet_diagnostic.SA1515.severity = warning

# SA1516: ElementsMustBeSeparatedByBlankLine
# Adjacent C# elements are not separated by a blank line.
dotnet_diagnostic.SA1516.severity = warning

# SA1517: CodeMustNotContainBlankLinesAtStartOfFile
# The code file has blank lines at the start.
dotnet_diagnostic.SA1517.severity = warning

# SA1518: UseLineEndingsCorrectlyAtEndOfFile
# The line endings at the end of a file do not match the settings for the project.
dotnet_diagnostic.SA1518.severity = warning

# SA1519: BracesMustNotBeOmittedFromMultiLineChildStatement
# The opening and closing braces for a multi-line C# statement have been omitted.
dotnet_diagnostic.SA1519.severity = warning

# SA1520: UseBracesConsistently
# The opening and closing braces of a chained if/else if/else construct were included for some clauses, but omitted for others.
# Disable reason: We allow else without new line and braces.
dotnet_diagnostic.SA1520.severity = none


# SA1600: ElementsMustBeDocumented
# A C# code element is missing a documentation header.
dotnet_diagnostic.SA1600.severity = warning

# SA1601: PartialElementsMustBeDocumented
# A C# partial element is missing a documentation header.
dotnet_diagnostic.SA1601.severity = warning

# SA1602: EnumerationItemsMustBeDocumented
# An item within a C# enumeration is missing an Xml documentation header.
dotnet_diagnostic.SA1602.severity = warning

# SA1603: DocumentationMustContainValidXml
# The Xml within a C# element's document header is badly formed.
dotnet_diagnostic.SA1603.severity = warning

# SA1604: ElementDocumentationMustHaveSummary
# The Xml header documentation for a C# element is missing a <summary> tag.
dotnet_diagnostic.SA1604.severity = warning

# SA1605: PartialElementDocumentationMustHaveSummary
# The <summary> or <content> tag within the documentation header for a C# code element is missing or empty.
dotnet_diagnostic.SA1605.severity = warning

# SA1606: ElementDocumentationMustHaveSummaryText
# The <summary> tag within the documentation header for a C# code element is empty.
dotnet_diagnostic.SA1606.severity = warning

# SA1607: PartialElementDocumentationMustHaveSummaryText
# The <summary> or <content> tag within the documentation header for a C# code element is empty.
dotnet_diagnostic.SA1607.severity = warning

# SA1608: ElementDocumentationMustNotHaveDefaultSummary
# The <summary> tag within an element's Xml header documentation contains the default text generated by Visual Studio during the creation of the element.
dotnet_diagnostic.SA1608.severity = warning

# SA1609: PropertyDocumentationMustHaveValue
# The Xml header documentation for a C# property does not contain a <value> tag.
# Disable reason: We use proper description in summaries, we don't need values.
dotnet_diagnostic.SA1609.severity = none

# SA1610: PropertyDocumentationMustHaveValueText
# The Xml header documentation for a C# property contains an empty <value> tag.
dotnet_diagnostic.SA1610.severity = warning

# SA1611: ElementParametersMustBeDocumented
# A C# method, constructor, delegate or indexer element is missing documentation for one or more of its parameters.
dotnet_diagnostic.SA1611.severity = warning

# SA1612: ElementParameterDocumentationMustMatchElementParameters
# The documentation describing the parameters to a C# method, constructor, delegate or indexer element does not match the actual parameters on the element.
dotnet_diagnostic.SA1612.severity = warning

# SA1613: ElementParameterDocumentationMustDeclareParameterName
# A <param> tag within a C# element's documentation header is missing a name attribute containing the name of the parameter.
dotnet_diagnostic.SA1613.severity = warning

# SA1614: ElementParameterDocumentationMustHaveText
# A <param> tag within a C# element's documentation header is empty.
dotnet_diagnostic.SA1614.severity = warning

# SA1615: ElementReturnValueMustBeDocumented
# A C# element is missing documentation for its return value.
dotnet_diagnostic.SA1615.severity = warning

# SA1616: ElementReturnValueDocumentationMustHaveText
# The <returns> tag within a C# element's documentation header is empty.
dotnet_diagnostic.SA1616.severity = warning

# SA1617: VoidReturnValueMustNotBeDocumented
# A C# code element does not contain a return value, or returns void, but the documentation header for the element contains a <returns> tag.
dotnet_diagnostic.SA1617.severity = warning

# SA1618: GenericTypeParametersMustBeDocumented
# A generic C# element is missing documentation for one or more of its generic type parameters.
dotnet_diagnostic.SA1618.severity = warning

# SA1619: GenericTypeParametersMustBeDocumentedPartialClass
# A generic, partial C# element is missing documentation for one or more of its generic type parameters, and the documentation for the element contains a <summary> tag.
dotnet_diagnostic.SA1619.severity = warning

# SA1620: GenericTypeParameterDocumentationMustMatchTypeParameters
# The <typeparam> tags within the Xml header documentation for a generic C# element do not match the generic type parameters on the element.
dotnet_diagnostic.SA1620.severity = warning

# SA1621: GenericTypeParameterDocumentationMustDeclareParameterName
# A <typeparam> tag within the Xml header documentation for a generic C# element is missing a name attribute, or contains an empty name attribute.
dotnet_diagnostic.SA1621.severity = warning

# SA1622: GenericTypeParameterDocumentationMustHaveText
# A <typeparam> tag within the Xml header documentation for a generic C# element is empty.
dotnet_diagnostic.SA1622.severity = warning

# SA1623: PropertySummaryDocumentationMustMatchAccessors
# The documentation text within a C# property's <summary> tag does not match the accessors within the property.
# Disable reason: We do not prescribe templates for documentation.
dotnet_diagnostic.SA1623.severity = none

# SA1624: PropertySummaryDocumentationMustOmitSetAccessorWithRestrictedAccess
# The documentation text within a C# property's <summary> tag takes into account all of the accessors within the property, but one of the accessors has limited access.
dotnet_diagnostic.SA1624.severity = warning

# SA1625: ElementDocumentationMustNotBeCopiedAndPasted
# The Xml documentation for a C# element contains two or more identical entries, indicating that the documentation has been copied and pasted.
dotnet_diagnostic.SA1625.severity = warning

# SA1626: SingleLineCommentsMustNotUseDocumentationStyleSlashes
# The C# code contains a single-line comment which begins with three forward slashes in a row.
dotnet_diagnostic.SA1626.severity = warning

# SA1627: DocumentationTextMustNotBeEmpty
# The Xml header documentation for a C# code element contains an empty tag.
dotnet_diagnostic.SA1627.severity = warning

# SA1628: DocumentationTextMustBeginWithACapitalLetter
# A section of the Xml header documentation for a C# element does not begin with a capital letter.
dotnet_diagnostic.SA1628.severity = warning

# SA1629: DocumentationTextMustEndWithAPeriod
# A section of the Xml header documentation for a C# element does not end with a period (also known as a full stop).
dotnet_diagnostic.SA1629.severity = warning

# SA1630: DocumentationTextMustContainWhitespace
# A section of the Xml header documentation for a C# element does not contain any whitespace between words.
dotnet_diagnostic.SA1630.severity = warning

# SA1631: DocumentationMustMeetCharacterPercentage
# A section of the Xml header documentation for a C# element does not contain enough alphabetic characters.
dotnet_diagnostic.SA1631.severity = warning

# SA1632: DocumentationTextMustMeetMinimumCharacterLength
# From StyleCop 4.5 this rule is disabled by default.
dotnet_diagnostic.SA1632.severity = warning

# SA1633: FileMustHaveHeader
# A C# code file is missing a standard file header.
# Disable reason: We do not require file headers.
dotnet_diagnostic.SA1633.severity = none

# SA1634: FileHeaderMustShowCopyright
# The file header at the top of a C# code file is missing a copyright tag.
dotnet_diagnostic.SA1634.severity = warning

# SA1635: FileHeaderMustHaveCopyrightText
# The file header at the top of a C# code file is missing copyright text.
dotnet_diagnostic.SA1635.severity = warning

# SA1636: FileHeaderCopyrightTextMustMatch
# The file header at the top of a C# code file does not contain the appropriate copyright text.
dotnet_diagnostic.SA1636.severity = warning

# SA1637: FileHeaderMustContainFileName
# The file header at the top of a C# code file is missing the file name.
dotnet_diagnostic.SA1637.severity = warning

# SA1638: FileHeaderFileNameDocumentationMustMatchFileName
# The file tag within the file header at the top of a C# code file does not contain the name of the file.
dotnet_diagnostic.SA1638.severity = warning

# SA1639: FileHeaderMustHaveSummary
# The file header at the top of a C# code file does not contain a filled-in summary tag.
dotnet_diagnostic.SA1639.severity = warning

# SA1640: FileHeaderMustHaveValidCompanyText
# The file header at the top of a C# code file does not contain company name text.
dotnet_diagnostic.SA1640.severity = warning

# SA1641: FileHeaderCompanyNameTextMustMatch
# The file header at the top of a C# code file does not contain the appropriate company name text.
dotnet_diagnostic.SA1641.severity = warning

# SA1642: ConstructorSummaryDocumentationMustBeginWithStandardText
# The XML documentation header for a C# constructor does not contain the appropriate summary text.
# Disable reason: We do not prescribe standard texts.
dotnet_diagnostic.SA1642.severity = none

# SA1643: DestructorSummaryDocumentationMustBeginWithStandardText
# The Xml documentation header for a C# finalizer does not contain the appropriate summary text.
dotnet_diagnostic.SA1643.severity = warning

# SA1644: DocumentationHeadersMustNotContainBlankLines
# A section within the Xml documentation header for a C# element contains blank lines.
dotnet_diagnostic.SA1644.severity = warning

# SA1645: IncludedDocumentationFileDoesNotExist
# An included Xml documentation file does not exist.
dotnet_diagnostic.SA1645.severity = warning

# SA1646: IncludedDocumentationXPathDoesNotExist
# An included Xml documentation link contains an invalid path.
dotnet_diagnostic.SA1646.severity = warning

# SA1647: IncludeNodeDoesNotContainValidFileAndPath
# An include tag within an Xml documentation header does not contain valid file and path attribute.
dotnet_diagnostic.SA1647.severity = warning

# SA1648: InheritDocMustBeUsedWithInheritingClass
# <inheritdoc> has been used on an element that doesn't inherit from a base class or implement an interface.
dotnet_diagnostic.SA1648.severity = warning

# SA1649: FileNameMustMatchTypeName
# The file name of a C# code file does not match the first type declared in the file.
# Disable reason: Sometimes we have multiple classes in a file.
dotnet_diagnostic.SA1649.severity = none

# SA1650: ElementDocumentationMustBeSpelledCorrectly
# The element documentation for the element contains one or more spelling mistakes or unrecognized words.
dotnet_diagnostic.SA1650.severity = warning

# SA1651: DoNotUsePlaceholderElements
# The documentation for the element contains one or more <placeholder> elements.
dotnet_diagnostic.SA1651.severity = warning

# SA1652: EnableXmlDocumentationOutput
# This rule was moved to SA0001
dotnet_diagnostic.SA1652.severity = warning

# SX1101: DoNotPrefixLocalMembersWithThis
# A call to an instance member of the local class or a base class is prefixed with 'this.', within a C# code file.
# Disable reason: We use 'this.' everywhere.
dotnet_diagnostic.SX1101.severity = none

# SX1309: FieldNamesMustBeginWithUnderscore
# A field name does not begin with an underscore.
# Disable reason: We do not use underscore notation.
dotnet_diagnostic.SX1309.severity = none

# SX1309S: StaticFieldNamesMustBeginWithUnderscore
# A static field name does not begin with an underscore.
# Disable reason: We do not use underscore notation.
dotnet_diagnostic.SX1309S.severity = none


# Rules missing in Microsoft documentation

dotnet_diagnostic.CA1300.severity = warning
dotnet_diagnostic.CA1301.severity = warning

dotnet_diagnostic.CA2101.severity = warning

# CA2210: Assemblies should have valid strong names
# This rule retrieves and verifies the strong name of an assembly.
dotnet_diagnostic.CA2210.severity = warning

dotnet_diagnostic.CA5358.severity = warning
dotnet_diagnostic.CA5403.severity = warning

dotnet_diagnostic.CS0618.severity = warning

dotnet_diagnostic.C26100.severity = warning
dotnet_diagnostic.C26101.severity = warning
dotnet_diagnostic.C26102.severity = warning
dotnet_diagnostic.C26105.severity = warning
dotnet_diagnostic.C26106.severity = warning
dotnet_diagnostic.C26110.severity = warning
dotnet_diagnostic.C26111.severity = warning
dotnet_diagnostic.C26112.severity = warning
dotnet_diagnostic.C26115.severity = warning
dotnet_diagnostic.C26116.severity = warning
dotnet_diagnostic.C26117.severity = warning
dotnet_diagnostic.C26130.severity = warning
dotnet_diagnostic.C26135.severity = warning
dotnet_diagnostic.C26136.severity = warning
dotnet_diagnostic.C26137.severity = warning
dotnet_diagnostic.C26138.severity = warning
dotnet_diagnostic.C26140.severity = warning
dotnet_diagnostic.C26160.severity = warning
dotnet_diagnostic.C26165.severity = warning
dotnet_diagnostic.C26166.severity = warning
dotnet_diagnostic.C26167.severity = warning
dotnet_diagnostic.C26400.severity = warning
dotnet_diagnostic.C26401.severity = warning
dotnet_diagnostic.C26402.severity = warning
dotnet_diagnostic.C26403.severity = warning
dotnet_diagnostic.C26404.severity = warning
dotnet_diagnostic.C26405.severity = warning
dotnet_diagnostic.C26406.severity = warning
dotnet_diagnostic.C26407.severity = warning
dotnet_diagnostic.C26408.severity = warning
dotnet_diagnostic.C26409.severity = warning
dotnet_diagnostic.C26410.severity = warning
dotnet_diagnostic.C26411.severity = warning
dotnet_diagnostic.C26414.severity = warning
dotnet_diagnostic.C26415.severity = warning
dotnet_diagnostic.C26416.severity = warning
dotnet_diagnostic.C26417.severity = warning
dotnet_diagnostic.C26418.severity = warning
dotnet_diagnostic.C26426.severity = warning
dotnet_diagnostic.C26427.severity = warning
dotnet_diagnostic.C26429.severity = warning
dotnet_diagnostic.C26430.severity = warning
dotnet_diagnostic.C26431.severity = warning
dotnet_diagnostic.C26432.severity = warning
dotnet_diagnostic.C26433.severity = warning
dotnet_diagnostic.C26434.severity = warning
dotnet_diagnostic.C26435.severity = warning
dotnet_diagnostic.C26436.severity = warning
dotnet_diagnostic.C26437.severity = warning
dotnet_diagnostic.C26438.severity = warning
dotnet_diagnostic.C26439.severity = warning
dotnet_diagnostic.C26440.severity = warning
dotnet_diagnostic.C26441.severity = warning
dotnet_diagnostic.C26443.severity = warning
dotnet_diagnostic.C26444.severity = warning
dotnet_diagnostic.C26445.severity = warning
dotnet_diagnostic.C26446.severity = warning
dotnet_diagnostic.C26447.severity = warning
dotnet_diagnostic.C26448.severity = warning
dotnet_diagnostic.C26449.severity = warning
dotnet_diagnostic.C26450.severity = warning
dotnet_diagnostic.C26451.severity = warning
dotnet_diagnostic.C26452.severity = warning
dotnet_diagnostic.C26453.severity = warning
dotnet_diagnostic.C26454.severity = warning
dotnet_diagnostic.C26455.severity = warning
dotnet_diagnostic.C26456.severity = warning
dotnet_diagnostic.C26459.severity = warning
dotnet_diagnostic.C26460.severity = warning
dotnet_diagnostic.C26461.severity = warning
dotnet_diagnostic.C26462.severity = warning
dotnet_diagnostic.C26463.severity = warning
dotnet_diagnostic.C26464.severity = warning
dotnet_diagnostic.C26465.severity = warning
dotnet_diagnostic.C26466.severity = warning
dotnet_diagnostic.C26471.severity = warning
dotnet_diagnostic.C26472.severity = warning
dotnet_diagnostic.C26473.severity = warning
dotnet_diagnostic.C26474.severity = warning
dotnet_diagnostic.C26475.severity = warning
dotnet_diagnostic.C26476.severity = warning
dotnet_diagnostic.C26477.severity = warning
dotnet_diagnostic.C26478.severity = warning
dotnet_diagnostic.C26481.severity = warning
dotnet_diagnostic.C26482.severity = warning
dotnet_diagnostic.C26483.severity = warning
dotnet_diagnostic.C26485.severity = warning
dotnet_diagnostic.C26486.severity = warning
dotnet_diagnostic.C26487.severity = warning
dotnet_diagnostic.C26488.severity = warning
dotnet_diagnostic.C26489.severity = warning
dotnet_diagnostic.C26490.severity = warning
dotnet_diagnostic.C26491.severity = warning
dotnet_diagnostic.C26492.severity = warning
dotnet_diagnostic.C26493.severity = warning
dotnet_diagnostic.C26494.severity = warning
dotnet_diagnostic.C26495.severity = warning
dotnet_diagnostic.C26496.severity = warning
dotnet_diagnostic.C26497.severity = warning
dotnet_diagnostic.C26498.severity = warning
dotnet_diagnostic.C26800.severity = warning
dotnet_diagnostic.C26810.severity = warning
dotnet_diagnostic.C26811.severity = warning
dotnet_diagnostic.C26812.severity = warning
dotnet_diagnostic.C26814.severity = warning
dotnet_diagnostic.C28020.severity = warning
dotnet_diagnostic.C28021.severity = warning
dotnet_diagnostic.C28022.severity = warning
dotnet_diagnostic.C28023.severity = warning
dotnet_diagnostic.C28024.severity = warning
dotnet_diagnostic.C28039.severity = warning
dotnet_diagnostic.C28101.severity = warning
dotnet_diagnostic.C28103.severity = warning
dotnet_diagnostic.C28104.severity = warning
dotnet_diagnostic.C28105.severity = warning
dotnet_diagnostic.C28106.severity = warning
dotnet_diagnostic.C28107.severity = warning
dotnet_diagnostic.C28108.severity = warning
dotnet_diagnostic.C28109.severity = warning
dotnet_diagnostic.C28110.severity = warning
dotnet_diagnostic.C28111.severity = warning
dotnet_diagnostic.C28112.severity = warning
dotnet_diagnostic.C28113.severity = warning
dotnet_diagnostic.C28114.severity = warning
dotnet_diagnostic.C28120.severity = warning
dotnet_diagnostic.C28121.severity = warning
dotnet_diagnostic.C28122.severity = warning
dotnet_diagnostic.C28123.severity = warning
dotnet_diagnostic.C28124.severity = warning
dotnet_diagnostic.C28125.severity = warning
dotnet_diagnostic.C28126.severity = warning
dotnet_diagnostic.C28127.severity = warning
dotnet_diagnostic.C28128.severity = warning
dotnet_diagnostic.C28129.severity = warning
dotnet_diagnostic.C28131.severity = warning
dotnet_diagnostic.C28132.severity = warning
dotnet_diagnostic.C28133.severity = warning
dotnet_diagnostic.C28134.severity = warning
dotnet_diagnostic.C28135.severity = warning
dotnet_diagnostic.C28137.severity = warning
dotnet_diagnostic.C28138.severity = warning
dotnet_diagnostic.C28141.severity = warning
dotnet_diagnostic.C28143.severity = warning
dotnet_diagnostic.C28144.severity = warning
dotnet_diagnostic.C28145.severity = warning
dotnet_diagnostic.C28146.severity = warning
dotnet_diagnostic.C28147.severity = warning
dotnet_diagnostic.C28150.severity = warning
dotnet_diagnostic.C28151.severity = warning
dotnet_diagnostic.C28152.severity = warning
dotnet_diagnostic.C28153.severity = warning
dotnet_diagnostic.C28156.severity = warning
dotnet_diagnostic.C28157.severity = warning
dotnet_diagnostic.C28158.severity = warning
dotnet_diagnostic.C28159.severity = warning
dotnet_diagnostic.C28160.severity = warning
dotnet_diagnostic.C28161.severity = warning
dotnet_diagnostic.C28162.severity = warning
dotnet_diagnostic.C28163.severity = warning
dotnet_diagnostic.C28164.severity = warning
dotnet_diagnostic.C28165.severity = warning
dotnet_diagnostic.C28166.severity = warning
dotnet_diagnostic.C28167.severity = warning
dotnet_diagnostic.C28168.severity = warning
dotnet_diagnostic.C28169.severity = warning
dotnet_diagnostic.C28170.severity = warning
dotnet_diagnostic.C28171.severity = warning
dotnet_diagnostic.C28172.severity = warning
dotnet_diagnostic.C28173.severity = warning
dotnet_diagnostic.C28175.severity = warning
dotnet_diagnostic.C28176.severity = warning
dotnet_diagnostic.C28182.severity = warning
dotnet_diagnostic.C28183.severity = warning
dotnet_diagnostic.C28193.severity = warning
dotnet_diagnostic.C28194.severity = warning
dotnet_diagnostic.C28195.severity = warning
dotnet_diagnostic.C28196.severity = warning
dotnet_diagnostic.C28197.severity = warning
dotnet_diagnostic.C28198.severity = warning
dotnet_diagnostic.C28199.severity = warning
dotnet_diagnostic.C28202.severity = warning
dotnet_diagnostic.C28203.severity = warning
dotnet_diagnostic.C28204.severity = warning
dotnet_diagnostic.C28205.severity = warning
dotnet_diagnostic.C28206.severity = warning
dotnet_diagnostic.C28207.severity = warning
dotnet_diagnostic.C28208.severity = warning
dotnet_diagnostic.C28209.severity = warning
dotnet_diagnostic.C28210.severity = warning
dotnet_diagnostic.C28211.severity = warning
dotnet_diagnostic.C28212.severity = warning
dotnet_diagnostic.C28213.severity = warning
dotnet_diagnostic.C28214.severity = warning
dotnet_diagnostic.C28215.severity = warning
dotnet_diagnostic.C28216.severity = warning
dotnet_diagnostic.C28217.severity = warning
dotnet_diagnostic.C28218.severity = warning
dotnet_diagnostic.C28219.severity = warning
dotnet_diagnostic.C28220.severity = warning
dotnet_diagnostic.C28221.severity = warning
dotnet_diagnostic.C28222.severity = warning
dotnet_diagnostic.C28223.severity = warning
dotnet_diagnostic.C28224.severity = warning
dotnet_diagnostic.C28225.severity = warning
dotnet_diagnostic.C28226.severity = warning
dotnet_diagnostic.C28227.severity = warning
dotnet_diagnostic.C28228.severity = warning
dotnet_diagnostic.C28229.severity = warning
dotnet_diagnostic.C28230.severity = warning
dotnet_diagnostic.C28231.severity = warning
dotnet_diagnostic.C28232.severity = warning
dotnet_diagnostic.C28233.severity = warning
dotnet_diagnostic.C28234.severity = warning
dotnet_diagnostic.C28235.severity = warning
dotnet_diagnostic.C28236.severity = warning
dotnet_diagnostic.C28237.severity = warning
dotnet_diagnostic.C28238.severity = warning
dotnet_diagnostic.C28239.severity = warning
dotnet_diagnostic.C28240.severity = warning
dotnet_diagnostic.C28241.severity = warning
dotnet_diagnostic.C28243.severity = warning
dotnet_diagnostic.C28244.severity = warning
dotnet_diagnostic.C28245.severity = warning
dotnet_diagnostic.C28246.severity = warning
dotnet_diagnostic.C28250.severity = warning
dotnet_diagnostic.C28251.severity = warning
dotnet_diagnostic.C28252.severity = warning
dotnet_diagnostic.C28253.severity = warning
dotnet_diagnostic.C28254.severity = warning
dotnet_diagnostic.C28260.severity = warning
dotnet_diagnostic.C28262.severity = warning
dotnet_diagnostic.C28263.severity = warning
dotnet_diagnostic.C28266.severity = warning
dotnet_diagnostic.C28267.severity = warning
dotnet_diagnostic.C28272.severity = warning
dotnet_diagnostic.C28273.severity = warning
dotnet_diagnostic.C28275.severity = warning
dotnet_diagnostic.C28278.severity = warning
dotnet_diagnostic.C28279.severity = warning
dotnet_diagnostic.C28280.severity = warning
dotnet_diagnostic.C28282.severity = warning
dotnet_diagnostic.C28283.severity = warning
dotnet_diagnostic.C28284.severity = warning
dotnet_diagnostic.C28285.severity = warning
dotnet_diagnostic.C28286.severity = warning
dotnet_diagnostic.C28287.severity = warning
dotnet_diagnostic.C28288.severity = warning
dotnet_diagnostic.C28289.severity = warning
dotnet_diagnostic.C28290.severity = warning
dotnet_diagnostic.C28291.severity = warning
dotnet_diagnostic.C28300.severity = warning
dotnet_diagnostic.C28301.severity = warning
dotnet_diagnostic.C28302.severity = warning
dotnet_diagnostic.C28303.severity = warning
dotnet_diagnostic.C28304.severity = warning
dotnet_diagnostic.C28305.severity = warning
dotnet_diagnostic.C28306.severity = warning
dotnet_diagnostic.C28307.severity = warning
dotnet_diagnostic.C28308.severity = warning
dotnet_diagnostic.C28309.severity = warning
dotnet_diagnostic.C28350.severity = warning
dotnet_diagnostic.C28351.severity = warning
dotnet_diagnostic.C28601.severity = warning
dotnet_diagnostic.C28602.severity = warning
dotnet_diagnostic.C28604.severity = warning
dotnet_diagnostic.C28615.severity = warning
dotnet_diagnostic.C28616.severity = warning
dotnet_diagnostic.C28617.severity = warning
dotnet_diagnostic.C28623.severity = warning
dotnet_diagnostic.C28624.severity = warning
dotnet_diagnostic.C28625.severity = warning
dotnet_diagnostic.C28636.severity = warning
dotnet_diagnostic.C28637.severity = warning
dotnet_diagnostic.C28638.severity = warning
dotnet_diagnostic.C28639.severity = warning
dotnet_diagnostic.C28640.severity = warning
dotnet_diagnostic.C28645.severity = warning
dotnet_diagnostic.C28648.severity = warning
dotnet_diagnostic.C28649.severity = warning
dotnet_diagnostic.C28650.severity = warning
dotnet_diagnostic.C28714.severity = warning
dotnet_diagnostic.C28715.severity = warning
dotnet_diagnostic.C28716.severity = warning
dotnet_diagnostic.C28717.severity = warning
dotnet_diagnostic.C28719.severity = warning
dotnet_diagnostic.C28720.severity = warning
dotnet_diagnostic.C28721.severity = warning
dotnet_diagnostic.C28726.severity = warning
dotnet_diagnostic.C28727.severity = warning
dotnet_diagnostic.C28730.severity = warning
dotnet_diagnostic.C28735.severity = warning
dotnet_diagnostic.C28736.severity = warning
dotnet_diagnostic.C28750.severity = warning
dotnet_diagnostic.C28751.severity = warning
dotnet_diagnostic.C6001.severity = warning
dotnet_diagnostic.C6011.severity = warning
dotnet_diagnostic.C6014.severity = warning
dotnet_diagnostic.C6029.severity = warning
dotnet_diagnostic.C6031.severity = warning
dotnet_diagnostic.C6053.severity = warning
dotnet_diagnostic.C6054.severity = warning
dotnet_diagnostic.C6059.severity = warning
dotnet_diagnostic.C6063.severity = warning
dotnet_diagnostic.C6064.severity = warning
dotnet_diagnostic.C6066.severity = warning
dotnet_diagnostic.C6067.severity = warning
dotnet_diagnostic.C6101.severity = warning
dotnet_diagnostic.C6200.severity = warning
dotnet_diagnostic.C6201.severity = warning
dotnet_diagnostic.C6211.severity = warning
dotnet_diagnostic.C6214.severity = warning
dotnet_diagnostic.C6215.severity = warning
dotnet_diagnostic.C6216.severity = warning
dotnet_diagnostic.C6217.severity = warning
dotnet_diagnostic.C6219.severity = warning
dotnet_diagnostic.C6220.severity = warning
dotnet_diagnostic.C6221.severity = warning
dotnet_diagnostic.C6225.severity = warning
dotnet_diagnostic.C6226.severity = warning
dotnet_diagnostic.C6230.severity = warning
dotnet_diagnostic.C6235.severity = warning
dotnet_diagnostic.C6236.severity = warning
dotnet_diagnostic.C6237.severity = warning
dotnet_diagnostic.C6239.severity = warning
dotnet_diagnostic.C6240.severity = warning
dotnet_diagnostic.C6242.severity = warning
dotnet_diagnostic.C6244.severity = warning
dotnet_diagnostic.C6246.severity = warning
dotnet_diagnostic.C6248.severity = warning
dotnet_diagnostic.C6250.severity = warning
dotnet_diagnostic.C6255.severity = warning
dotnet_diagnostic.C6258.severity = warning
dotnet_diagnostic.C6259.severity = warning
dotnet_diagnostic.C6260.severity = warning
dotnet_diagnostic.C6262.severity = warning
dotnet_diagnostic.C6263.severity = warning
dotnet_diagnostic.C6268.severity = warning
dotnet_diagnostic.C6269.severity = warning
dotnet_diagnostic.C6270.severity = warning
dotnet_diagnostic.C6271.severity = warning
dotnet_diagnostic.C6272.severity = warning
dotnet_diagnostic.C6273.severity = warning
dotnet_diagnostic.C6274.severity = warning
dotnet_diagnostic.C6276.severity = warning
dotnet_diagnostic.C6277.severity = warning
dotnet_diagnostic.C6278.severity = warning
dotnet_diagnostic.C6279.severity = warning
dotnet_diagnostic.C6280.severity = warning
dotnet_diagnostic.C6281.severity = warning
dotnet_diagnostic.C6282.severity = warning
dotnet_diagnostic.C6283.severity = warning
dotnet_diagnostic.C6284.severity = warning
dotnet_diagnostic.C6285.severity = warning
dotnet_diagnostic.C6286.severity = warning
dotnet_diagnostic.C6287.severity = warning
dotnet_diagnostic.C6288.severity = warning
dotnet_diagnostic.C6289.severity = warning
dotnet_diagnostic.C6290.severity = warning
dotnet_diagnostic.C6291.severity = warning
dotnet_diagnostic.C6292.severity = warning
dotnet_diagnostic.C6293.severity = warning
dotnet_diagnostic.C6294.severity = warning
dotnet_diagnostic.C6295.severity = warning
dotnet_diagnostic.C6296.severity = warning
dotnet_diagnostic.C6297.severity = warning
dotnet_diagnostic.C6298.severity = warning
dotnet_diagnostic.C6299.severity = warning
dotnet_diagnostic.C6302.severity = warning
dotnet_diagnostic.C6303.severity = warning
dotnet_diagnostic.C6305.severity = warning
dotnet_diagnostic.C6306.severity = warning
dotnet_diagnostic.C6308.severity = warning
dotnet_diagnostic.C6310.severity = warning
dotnet_diagnostic.C6312.severity = warning
dotnet_diagnostic.C6313.severity = warning
dotnet_diagnostic.C6314.severity = warning
dotnet_diagnostic.C6315.severity = warning
dotnet_diagnostic.C6316.severity = warning
dotnet_diagnostic.C6317.severity = warning
dotnet_diagnostic.C6318.severity = warning
dotnet_diagnostic.C6319.severity = warning
dotnet_diagnostic.C6320.severity = warning
dotnet_diagnostic.C6322.severity = warning
dotnet_diagnostic.C6323.severity = warning
dotnet_diagnostic.C6324.severity = warning
dotnet_diagnostic.C6326.severity = warning
dotnet_diagnostic.C6328.severity = warning
dotnet_diagnostic.C6329.severity = warning
dotnet_diagnostic.C6330.severity = warning
dotnet_diagnostic.C6331.severity = warning
dotnet_diagnostic.C6332.severity = warning
dotnet_diagnostic.C6333.severity = warning
dotnet_diagnostic.C6334.severity = warning
dotnet_diagnostic.C6335.severity = warning
dotnet_diagnostic.C6336.severity = warning
dotnet_diagnostic.C6340.severity = warning
dotnet_diagnostic.C6381.severity = warning
dotnet_diagnostic.C6383.severity = warning
dotnet_diagnostic.C6384.severity = warning
dotnet_diagnostic.C6385.severity = warning
dotnet_diagnostic.C6386.severity = warning
dotnet_diagnostic.C6387.severity = warning
dotnet_diagnostic.C6388.severity = warning
dotnet_diagnostic.C6400.severity = warning
dotnet_diagnostic.C6401.severity = warning
dotnet_diagnostic.C6411.severity = warning
dotnet_diagnostic.C6412.severity = warning
dotnet_diagnostic.C6500.severity = warning
dotnet_diagnostic.C6501.severity = warning
dotnet_diagnostic.C6503.severity = warning
dotnet_diagnostic.C6504.severity = warning
dotnet_diagnostic.C6505.severity = warning
dotnet_diagnostic.C6506.severity = warning
dotnet_diagnostic.C6508.severity = warning
dotnet_diagnostic.C6509.severity = warning
dotnet_diagnostic.C6510.severity = warning
dotnet_diagnostic.C6511.severity = warning
dotnet_diagnostic.C6513.severity = warning
dotnet_diagnostic.C6514.severity = warning
dotnet_diagnostic.C6515.severity = warning
dotnet_diagnostic.C6516.severity = warning
dotnet_diagnostic.C6517.severity = warning
dotnet_diagnostic.C6518.severity = warning
dotnet_diagnostic.C6522.severity = warning
dotnet_diagnostic.C6525.severity = warning
dotnet_diagnostic.C6527.severity = warning
dotnet_diagnostic.C6530.severity = warning
dotnet_diagnostic.C6540.severity = warning
dotnet_diagnostic.C6551.severity = warning
dotnet_diagnostic.C6552.severity = warning
dotnet_diagnostic.C6701.severity = warning
dotnet_diagnostic.C6702.severity = warning
dotnet_diagnostic.C6703.severity = warning
dotnet_diagnostic.C6704.severity = warning
dotnet_diagnostic.C6705.severity = warning
dotnet_diagnostic.C6706.severity = warning
dotnet_diagnostic.C6707.severity = warning
dotnet_diagnostic.C6993.severity = warning
dotnet_diagnostic.C6995.severity = warning
dotnet_diagnostic.C6997.severity = warning

# IDE0017: Use object initializers
# Disable reason: We usually do not accept advanced forms of this analyzer. We decide for ourselves on case by case basis.
dotnet_diagnostic.IDE0017.severity = silent

# IDE0022: Use expression body for methods
# Disable reason: We usually prefer full bodies for methods, but sometimes we use expression bodies. We decide for ourselves on case by case basis.
dotnet_diagnostic.IDE0022.severity = none

# IDE0028: Simplify collection initialization
# This style rule concerns the use of collection initializers for collection initialization.
# Disable reason: The analyzer suggests new array notation (i.e. `[]`) and we do not want to use it at the moment.
dotnet_diagnostic.IDE0028.severity = none

# IDE0039: Use local function instead of lambda
# This style rule concerns the use of local functions versus lambda expressions (anonymous functions).
# Disable reason: We often prefer lamdas. To make it easy to switch from a lambda to a local function, the analyzer is set to the silent level.
dotnet_diagnostic.IDE0039.severity = silent

# IDE0045: Use conditional expression for assignment 
# Disable reason: We often prefer longer and easier to read form.
dotnet_diagnostic.IDE0045.severity = none

# IDE0046: Use conditional expression for return
# Disable reason: We often prefer longer and easier to read form.
dotnet_diagnostic.IDE0046.severity = none

# IDE0053: Use expression body for lambdas
# Disable reason: We usually prefer full bodies for lambdas, but sometimes we use expression bodies. We decide for ourselves on case by case basis.
dotnet_diagnostic.IDE0053.severity = none

# IDE0057: Substring can be simplified
# Disable reason: We often prefer longer and easier to read form.
dotnet_diagnostic.IDE0057.severity = none

# IDE0063: Using can be simplified
# Disable reason: We want to decide about each specific case separately.
dotnet_diagnostic.IDE0063.severity = none

# IDE0074: Use compound assignment
# Disable reason: We often use explicit if statements. To make it easy to switch from an if to a compound assignment, the analyzer is set to the silent level.
dotnet_diagnostic.IDE0074.severity = silent

# IDE1006: Naming rule violation: Words must begin with upper case characters
# Disable reason: We use identifiers starting with lower case letters for private and protected fields and properties.
dotnet_diagnostic.IDE1006.severity = none

# IDE0130: Namespace does not match folder structure
# This style rule uses the folder structure of the project to enforce namespace naming requirements.
dotnet_diagnostic.IDE0130.severity = warning

# IDE0180: Use tuple to swap values
# This style rule flags code that swaps two values using multiple lines of code instead of using a tuple.
# Disable reason: We do not use tuples as a general rule.
dotnet_diagnostic.IDE0180.severity = none

# IDE0220: Add explicit cast in foreach loop
# This rule flags the absence of an explicit cast in a `foreach` loop when the compiler would add a hidden cast. For generic, or strongly typed, collections, forcing 
# an explicit cast when the compiler would add a hidden cast can uncover the use of an incorrect type in the `foreach` statement.
dotnet_diagnostic.IDE0220.severity = warning

# IDE0230: Use UTF-8 string literal
# This rule flags the use of a byte array (byte[]) where a UTF-8 string literal could be used instead. Using a UTF-8 string literal adds clarity to the declaration.
dotnet_diagnostic.IDE0230.severity = warning

# IDE0290: Use primary constructor
# This rule flags classes that can use a primary constructor instead of a separate constructor definition. You define a primary constructor by placing any constructor parameters 
# in parentheses following the type name. A primary constructor indicates that these parameters are necessary for any instance of the type.
# Disable reason: We prefer not to use primary constructors to avoid big code changes and to avoid early tooling issues.
dotnet_diagnostic.IDE0290.severity = none

# IDE0300: Simplify collection initialization
# Disable reason: We prefer not to use simplified collection initializations at the moment to avoid big code changes and to avoid early tooling issues.
dotnet_diagnostic.IDE0300.severity = none

# IDE0301: Use collection expression for empty
# This rule looks for code similar to Array.Empty<T>() (a method call that returns an empty collection) or ImmutableArray<T>.Empty (a property that returns an empty collection) 
# and offers to replace it with a collection expression ([]).
# Disable reason: We prefer not to use the new collection expression (i.e. []) at the moment to avoid big code changes and to avoid early tooling issues.
dotnet_diagnostic.IDE0301.severity = none

# IDE0305: Collection initialization can be simplified
# Disable reason: We prefer not to use the new collection expression (i.e. []) at the moment to avoid big code changes and to avoid early tooling issues.
dotnet_diagnostic.IDE0305.severity = none

# IDE0306: Collection initialization can be simplified
# Disable reason: We prefer not to use the new collection expression (i.e. []) at the moment to avoid big code changes and to avoid early tooling issues.
dotnet_diagnostic.IDE0306.severity = none

# RS0030: Do not use banned APIs
# The symbol has been marked as banned in this project, and an alternate should be used instead.
dotnet_diagnostic.RS0030.severity = warning

# xUnit1030: Do not call ConfigureAwait in test method
# Developers should not call ConfigureAwait(false) against tasks in a test method, as this may cause parallelization issues like running too many tests in parallel.
dotnet_diagnostic.xUnit1030.severity = warning

# VSTHRD003: Avoid awaiting foreign Tasks
# Tasks that are created and run from another context (not within the currently running method or delegate) should not be returned or awaited on. Doing so can result in deadlocks
# because awaiting a Task does not result in the awaiter "joining" the effort such that access to the main thread is shared. If the awaited Task requires the main thread, and the
# caller that is awaiting it is blocking the main thread, a deadlock will result.
# Disable reason: Whale's Secret Core is not a UI application.
dotnet_diagnostic.VSTHRD003.severity = none

# Test files
[*{Test.cs,Tests.cs}]

# CA1859: Use concrete types when possible for improved performance
# Disable reason: In tests, performance is not really an objective. Code clarity is more important.
dotnet_diagnostic.CA1859.severity = none

# CA1869: Cache and reuse 'JsonSerializerOptions' instances
# Disable reason: In tests, performance is not really an objective. Code clarity is more important.
dotnet_diagnostic.CA1869.severity = none